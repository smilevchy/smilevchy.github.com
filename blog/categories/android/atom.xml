<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2015-01-19T10:38:15+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Something About Installing Genymotion]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/28/something-about-installing-genymotion/"/>
    <updated>2014-12-28T16:21:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/28/something-about-installing-genymotion</id>
    <content type="html"><![CDATA[<p>趁着有时间安装了 Genymotion，它需要依据 Oracle 的 VirtualBox 来工作，所以就是说你还需要安装 Oracle VM VirtualBox 这个软件。</p>

<p>一般设计上来说，Genymotion 应该要提供一个位置来设置指向 VirtualBox 软件路径的，可是找了它的安装目录、软件界面设置都没有发现这个位置，所以就是说，它可能是固定指向 VirtualBox 的。</p>

<p>即，需要按照它给定的固定路径来安装 VirtualBox ，不然就无法启动成功。至于那个固定路径是什么，可以去它的日志文件里查找，如果没什么改变的话，位置一般是在用户数据文件夹里，名字为 genymotion.log。通过查看它的错误日志，找到指向 VirtualBox 时发生错误的日志记录，那里就有写该固定路径。</p>

<p>这是我自己遇到的错误，因为在安装 Genymotion 前我就一直使用 VirtualBox ，而且是自定义路径。 &ndash;_-所以需要卸载重装，安装它的固定路径。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interrogation of AsyncTask]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/11/interrogation-of-asynctask/"/>
    <updated>2014-12-11T20:48:12+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/11/interrogation-of-asynctask</id>
    <content type="html"><![CDATA[<p>当需要进行一项耗时久的任务时（下载文件、访问网络等），一般都知道必须在 worker thread 中进行。但是在现实场景中不可能单纯新建一个线程那么简单，大部分时候需要和 main thread 进行交互、或者说还要保证任务能够成功进行，不会遇到被销毁的情况。可是，单纯的 thread 并不具备这些能力。</p>

<p>那怎么办呢？</p>

<!-- more -->


<p>以上说的场景交互在 Android 开发中形成了一种 pattern，而 Android 团队就把这种 pattern 提取成了一个工具类出来给开发者使用，即 AsyncTask。</p>

<p>关于 AsyncTask 的使用方法可参见<a href="http://developer.android.com/reference/android/os/AsyncTask.html">官方文档</a>。</p>

<p>一般情况下，AsyncTask 的确就是那么容易使用。但在某些情况下，你会发现这个类出问题了。</p>

<p>这个是因为 AsyncTask 的本质缺陷导致。</p>

<p>Android 的基本组件 Activity/Receiver/Service 本身具有一定的生命周期管理（Life Circle Management），而 AsyncTask 并不具备与之对应的生命周期管理。</p>

<p>假设一个场景如下，你编写了一个 AsyncTask，然后在一个 Activity 里调用该 AsyncTask，并且把自身引用传递进去，为了后续的一些函数调用。大部分情况下是没有问题，但是当设备转换屏幕方向时，Android 系统会销毁这个 Activity 再重建一个新的，此时之前传进去 AsyncTask 里的引用已经“无效”了，因为它指向了一个被销毁的 Activity，你再也不可能对其做任何 UI 操作，甚至会抛出 NullPointerException。即是说，你需要注意传进给 AsyncTask 的任何具有生命周期管理的引用，下一秒这个引用可能就失效了。</p>

<p>解决方法？</p>

<p>对于此类具有生命周期管理的引用统一使用 WeakReference，当引用指向的对象被系统销毁时，可以让这些对象被 GC 处理，同时在使用到引用的代码处再判断是否非空来决定怎么处理。</p>

<p>此外，当外部发生生命周期状态改变时（按返回键、Home键、取消进度框等），若对应的 AsyncTask 需要做相应的反应时（取消任务进行、继续任务进行等），还需要监听外部的生命周期状态改变事件。</p>

<p>总之，AsyncTask 看起来很简单，但需要在实际场景中考虑是否可能会出现问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Game - CatRush]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/08/my-first-game-catrush/"/>
    <updated>2014-12-08T22:15:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/08/my-first-game-catrush</id>
    <content type="html"><![CDATA[<p>完成了第一个移动端游戏，其为 <a href="/assets/artifacts/CatRush.apk">CatRush</a>。</p>

<!-- more -->


<hr />

<p>展示如下所示(当当当~当):</p>

<p>首先是图标:</p>

<p><img src="/images/artifacts/catrush/icon.png" alt="图标" /></p>

<p>接下来是 &ldquo;启动画面&rdquo; (专业术语为 SplashScreen):</p>

<p><img src="/images/artifacts/catrush/splash_scene_1.png" alt="启动画面1" />
<img src="/images/artifacts/catrush/splash_scene_2.png" alt="启动画面2" />
<img src="/images/artifacts/catrush/splash_scene_3.png" alt="启动画面3" /></p>

<p>启动画面是一项很重要的元素。它可以做为一个公司或者个人的标识。通过持久的运营，让它变成一个品牌。让大家一看到这个标识就知道是哪个公司或者个人的作品。比如说漫威电影的开头都会有一段短动画，或者美国好莱坞的某个电影公司开头都会有一段闪电打雷开车在高速路上的动画。</p>

<p>启动画面后是 &ldquo;主菜单&rdquo; 画面:
<img src="/images/artifacts/catrush/main_menu_scene.png" alt="主菜单" /></p>

<p>&ldquo;关于&rdquo; 界面:
<img src="/images/artifacts/catrush/about_scene.png" alt="关于界面" /></p>

<p>&ldquo;选项&rdquo; 界面:
<img src="/images/artifacts/catrush/option_scene.png" alt="选项界面" /></p>

<p>&ldquo;分数记录&rdquo; 界面:
<img src="/images/artifacts/catrush/score_scene.png" alt="分数记录界面" />
这里触摸右下的小黑猫可以截屏分享当前最高分数至社交软件。</p>

<p>最后是 &ldquo;游戏界面&rdquo;
<img src="/images/artifacts/catrush/game_scene.png" alt="游戏界面" />
右边两只小黑爪一只是加速，一只是减速。</p>

<p>没错，你要做的就是控制小黑猫的速度，躲避天上掉下来的毛线团和秋刀鱼。</p>

<p>游戏中的音乐/音效资源均是采用别人的(不进行商业化就不会侵权了吧)，有<a href="http://zh.wikipedia.org/zh/%E5%B9%BB%E5%8C%96%E6%88%90%E9%A3%8E">幻化成风</a> 和<a href="http://zh.wikipedia.org/zh/%E5%8B%87%E6%B0%A3100%25">勇气100%</a>。</p>

<p>图片资源大部分是上网找的，有些是自己画的(没错，看起来是幼稚园水平的就是本人画的)。</p>

<hr />

<p>smilevchy: 关于本游戏正式介绍完毕。</p>

<p>猫老师: 喂!貌似你介绍的很简短啊!</p>

<p>smilevchy: Haha&hellip;&hellip;本人是一名程序员啊，对于游戏策划、数值设计、图片制作、音效/音乐制作目前还都是 HelloWorld 水平啊，请老师再给我点时间，让我好好历练一下吧。</p>

<p>猫老师: Soga！少年，请继续努力吧！</p>

<p>smilevchy: 好的! 猫老师。</p>

<p>猫老师: 对了，最后再问个问题。为什么猫要躲避毛线团和秋刀鱼啊，混蛋，吾等猫君可是很喜欢毛线团和秋刀鱼的喵。</p>

<p>smilevchy: 嘿嘿嘿，猫老师，这又是另一个故事了&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let Android Talk to Computer With Socket]]></title>
    <link href="http://smilevchy.github.io/blog/2014/09/16/let-android-talk-to-computer-with-socket/"/>
    <updated>2014-09-16T21:45:17+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/09/16/let-android-talk-to-computer-with-socket</id>
    <content type="html"><![CDATA[<p>在没有公网/wifi的情况下让 Android 手机通过 USB 或者让虚拟机里的 Android 系统与电脑进行通信。</p>

<!-- more -->


<p>基本原理是当 Android 手机通过 USB 连接电脑时，两者之间就形成了一个局域网（具体是由 ADB 实现的）。
嗯，看到这里只要了解网络编程的同学就知道怎么做了。
就是把 Android 手机作为服务器，监听某个端口来获取客户端连接,而 PC 可以作为客户端。
这里的问题是客户端要怎么连接到服务器的端口，这个需要运行 adb shell 指令 ：</p>

<pre><code>adb.exe forward tcp:[port1] tcp:[port2]  // port1: PC 上的端口; port2: Android 上的端口。此处会把 PC 上发往 port1 的信息转发至 Android 的 port2
</code></pre>

<p>Android 服务器代码：</p>

<pre><code>void startServer() {
    ServerSocket serverSocket = null;

    try {
        Log.e("Android", "start to accpet");

        serverSocket = new ServerSocket(SERVER_PORT); // 即 port2

        while (true) {
            Socket client = serverSocket.accept();

            Log.e("Android", "receive client");

            try {
                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
                final String str = in.readLine();

                Log.e("Android", str);

                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        show.setText(str);
                    }
                });

                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true);
                out.println("I'm Android");
                in.close();
                out.close();
            } catch (Exception e) {
                Log.e("Android", "");
                e.printStackTrace();
            } finally {
                client.close();
                Log.e("Android", "");
            }
            Thread.sleep(3000);
        }
    } catch (Exception e) {
        Log.e("Android", "");
        e.printStackTrace();
    } finally {
        if (serverSocket != null) {
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>

<p>PC 客户端代码：</p>

<pre><code>try {
        // 6665是 PC 端的端口，通过运行该 Shell 命令重定向到 Android Device 的6666端口 (端口自己定，不得超过1023)
        Runtime.getRuntime().exec("[Your Android SDK's Dir]\\platform-tools\\adb.exe forward tcp:6665 tcp:6666");
    } catch (IOException e) {
        e.printStackTrace();
        return;
    }

    Socket socket = null;
    try {
        InetAddress serverAddr = null;
        serverAddr = InetAddress.getByName("127.0.0.1");
        System.out.println("Start to connect android");

        socket = new Socket(serverAddr, 6665);

        String message = "I'm pc";
        System.out.println("Pc is sending message: " + message);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);
        out.println(message);
        Thread.sleep(5000);

        // receive message from server (Android Device)
        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        String msg = br.readLine();
        System.out.println(msg);
    } catch (UnknownHostException e) {
        System.out.println(e);
    } catch (IOException e) {
        System.out.println(e);
    } finally {
        try {
            if (socket != null) {
                socket.close();
            }
        } catch (IOException e) {
            System.out.println(e);
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
