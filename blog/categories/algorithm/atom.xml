<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-17T17:26:03+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Duplicates From Sorted List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-remove-duplicates-from-sorted-list/"/>
    <updated>2014-11-17T17:25:01+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head.next;

    while (quickCursor != null) {
        if (quickCursor.val != slowCursor.val) {
            slowCursor = slowCursor.next;
            quickCursor = quickCursor.next;

            continue;
        }

        slowCursor.next = quickCursor.next;
        quickCursor = quickCursor.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Triangle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-triangle/"/>
    <updated>2014-11-17T17:08:01+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-triangle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/triangle/">https://oj.leetcode.com/problems/triangle/</a></p>

<pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
    if (triangle == null) return 0;

    int size = triangle.size();
    int[] res = new int[triangle.get(size - 1).size()];

    for (int i = 0, s = triangle.get(size - 1).size(); i &lt; s; i++) {
        res[i] = triangle.get(size - 1).get(i);
    }

    for (int i = size - 2; i &gt;= 0; i--) {
        for (int j = 0; j &lt;= i; j++) {
            res[j] = Math.min(res[j], res[j + 1]) + triangle.get(i).get(j);
        }
    }

    return res[0];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Word Break]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/14/leetcode-word-break/"/>
    <updated>2014-11-14T17:45:56+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/14/leetcode-word-break</id>
    <content type="html"><![CDATA[<p>原题链接：<a href="https://oj.leetcode.com/problems/word-break/">https://oj.leetcode.com/problems/word-break/</a></p>

<!-- more -->


<p>&ndash;_&ndash; 一开始用的是穷举法，结果遇到超长字符串时 online-judge system 就会报 limited time exceed 的错。</p>

<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; dict) {
    if (s == null || s.length() == 0) return true;

    int length = s.length();
    boolean[] res = new boolean[length + 1];
    res[0] = true;

    for (int i = 0; i &lt; length; i++) {
        StringBuilder sb = new StringBuilder(s.substring(0, i + 1));

        for (int j = 0; j &lt;= i; j++) {
            if (res[j] &amp;&amp; dict.contains(sb.toString())) {
                res[i + 1] = true;

                break;
            }

            sb.deleteCharAt(0);
        }
    }

    return res[length];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Insertion Sort List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/12/leetcode-insertion-sort-list/"/>
    <updated>2014-11-12T16:32:44+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/12/leetcode-insertion-sort-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/insertion-sort-list/">https://oj.leetcode.com/problems/insertion-sort-list/</a></p>

<!-- more -->


<p>一开始的解法有考虑到当前待插节点的后续节点，其实是没必要的</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) return null;

    ListNode cursorOut = head.next;
    ListNode cursorOutPrev = head;

    while (cursorOut != null) {
        ListNode cursorIn = head;
        ListNode cursorInPrev = null;
        ListNode cursorOutNext = cursorOut.next;

        while (cursorIn != null &amp;&amp; cursorIn != cursorOut) {
            if (cursorIn.val &gt; cursorOut.val) {
                if (cursorInPrev != null) {
                    cursorInPrev.next = cursorOut;
                } else {
                    head = cursorOut;
                }
                cursorOutPrev.next = cursorOutNext;
                cursorOut.next = cursorIn;
                cursorOut = cursorOutPrev;

                break;
            }

            cursorInPrev = cursorIn;
            cursorIn = cursorIn.next;
        }

        cursorOutPrev = cursorOut;
        cursorOut = cursorOutNext;
    }
}
</code></pre>

<p>使用额外的一个节点来记录遍历位置</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) return null;

    ListNode insertedNode = head;
    ListNode cursor = new ListNode(0);
    ListNode prev = null;

    while (insertedNode != null) {
        ListNode insertedNodeNext = insertedNode.next;
        prev = cursor;

        while (prev.next != null &amp;&amp; prev.next.val &lt;= insertedNode.val) {
            prev = prev.next;
        }

        insertedNode.next = prev.next;
        prev.next = insertedNode;
        insertedNode = insertedNodeNext;
    }

    return cursor.next;
}       
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Roman to Integer]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/11/leetcode-roman-to-integer/"/>
    <updated>2014-11-11T18:31:43+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/11/leetcode-roman-to-integer</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/roman-to-integer/">https://oj.leetcode.com/problems/roman-to-integer/</a></p>

<!-- more -->


<pre><code>// I(1) V(5) X(10) L(50) C(100) D(500) M(1000)
public int romanToInt(String s) {
    if (s == null) return 0;

    s = s.trim();

    if (s.equals("")) return 0;

    int num = 0;
    int length = s.length();
    char cur;
    char next;

    for (int i = 0; i &lt; length; i++) {
        cur = s.charAt(i);

        switch (cur) {
            case 'I':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'V') {
                        num += 4;
                        i++;
                        continue;
                    } else if (next == 'X') {
                        num += 9;
                        i++;
                        continue;
                    }
                }

                num += 1;

                break;

            case 'V':
                num += 5;

                break;

            case 'X':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'L') {
                        num += 40;
                        i++;
                        continue;
                    } else if (next == 'C') {
                        num += 90;
                        i++;
                        continue;
                    }
                }

                num += 10;

                break;

            case 'L':
                num += 50;

                break;

            case 'C':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'D') {
                        num += 400;
                        i++;
                        continue;
                    } else if (next == 'M') {
                        num += 900;
                        i++;
                        continue;
                    }
                }

                num += 100;

                break;

            case 'D':
                num += 500;
                break;

            case 'M':
                num += 1000;
                break;
        }
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
