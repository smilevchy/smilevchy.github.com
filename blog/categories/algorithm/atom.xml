<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-21T15:25:16+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number/"/>
    <updated>2014-11-21T15:23:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number/">https://oj.leetcode.com/problems/single-number/</a></p>

<!-- more -->


<pre><code>PS: 利用异或运算可以用来加解密.

public int singleNumber(int[] A) {
    int num = 0;

    for (int i = 0, length = A.length; i &lt; length; i++) {
        num ^= A[i];
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Length of Last Word]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word/"/>
    <updated>2014-11-21T15:07:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/length-of-last-word/">https://oj.leetcode.com/problems/length-of-last-word/</a></p>

<!-- more -->


<pre><code>public int lengthOfLastWord(String s) {
    if (s == null) return 0;

    int lengthOfLastWord = 0;
    boolean meetSpace = false;
    char c;

    for (int i = 0, length = s.length(); i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case ' ':
                meetSpace = true;

                break;

            default:
                if (meetSpace) {
                    lengthOfLastWord = 0;
                    lengthOfLastWord++;
                    meetSpace = false;
                } else {
                    lengthOfLastWord++;
                }

                break;
        }
    }

    return lengthOfLastWord;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Postorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal/"/>
    <updated>2014-11-21T14:44:22+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">https://oj.leetcode.com/problems/binary-tree-postorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
    TreeNode prev = null;

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            TreeNode peek = stack.peek();

            if (peek.right != null &amp;&amp; peek.right != prev) {
                root = peek.right;
            } else {
                stack.pop();
                result.add(peek.val);
                prev = peek;
            }
        }
    }

    return result;
}

public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Inorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal/"/>
    <updated>2014-11-21T11:26:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(inorderTraversal(root.left));
    result.add(root.val);
    result.addAll(inorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Preorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal/"/>
    <updated>2014-11-20T18:17:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">https://oj.leetcode.com/problems/binary-tree-preorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            result.add(root.val);
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.add(root.val);
    result.addAll(preorderTraversal(root.left));
    result.addAll(preorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
