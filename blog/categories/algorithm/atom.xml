<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-10T22:23:31+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Longest Common Prefix]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/08/leetcode-longest-common-prefix/"/>
    <updated>2014-11-08T13:51:55+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/08/leetcode-longest-common-prefix</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/longest-common-prefix/">https://oj.leetcode.com/problems/longest-common-prefix/</a></p>

<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs == null) return null;
    if (strs.length == 0) return "";

    String shortestStr = null;

    // find the shortest string element
    for (int i = 0, s = strs.length; i &lt; s; i++) {
        if (shortestStr == null) {
            shortestStr = strs[i];
        } else if (strs[i].length() &lt; shortestStr.length()) {
            shortestStr = strs[i];
        }
    }

    StringBuilder longestCommonPrefix = new StringBuilder("");
    int shortestStrLen = shortestStr.length();
    char c;
    boolean quitMatch = false;

    for (int i = 0; i &lt; shortestStrLen; i++) {
        c = shortestStr.charAt(i);

        for (int j = 0, s = strs.length; j &lt; s; j++) {
            if (strs[j].charAt(i) != c) {
                quitMatch = true;
                break;
            }

            if (j == strs.length - 1) {
                longestCommonPrefix.append(c);
            }
        }

        if (quitMatch) break;
    }

    return longestCommonPrefix.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Palindrome]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome/"/>
    <updated>2014-11-07T16:28:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/valid-palindrome/">https://oj.leetcode.com/problems/valid-palindrome/</a></p>

<pre><code>public boolean isPalindrome(String s) {
    if (s == null) return false;

    s = s.trim();

    if (s.equals("")) return true;

    int i = 0;
    int j = s.length() - 1;
    char leftChar;
    char rightChar;

    while (i &lt; j) {
        leftChar = s.charAt(i);

        if ((leftChar &lt; 'a' || leftChar &gt; 'z') &amp;&amp; (leftChar &lt; 'A' || leftChar &gt; 'Z') &amp;&amp; (leftChar &lt; '0' || leftChar &gt; '9')) {
            i++;
            continue;
        }

        rightChar = s.charAt(j);

        if ((rightChar &lt; 'a' || rightChar &gt; 'z') &amp;&amp; (rightChar &lt; 'A' || rightChar &gt; 'Z') &amp;&amp; (rightChar &lt; '0' || rightChar &gt; '9')) {
            j--;
            continue;
        }

        if (leftChar &gt; rightChar) {
            if (leftChar - 32 != rightChar) return false;
        } else if (leftChar &lt; rightChar) {
            if (leftChar + 32 != rightChar) return false;
        }

        i++;
        j--;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Count and Say]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say/"/>
    <updated>2014-11-07T15:53:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/count-and-say/">https://oj.leetcode.com/problems/count-and-say/</a></p>

<pre><code>public String countAndSay(int n) {
    if (n &lt; 0) return "";

    StringBuilder sb = new StringBuilder();

    if (n == 1) {
        return sb.append("1").toString();
    }

    String prevStr = countAndSay(n - 1);
    int length = prevStr.length();
    char prevChar = ' '; 
    int accumulator = 0;

    for (int i = 0; i &lt; length; i++) {
        char c = prevStr.charAt(i);

        if (c == prevChar) {
            accumulator++;
        } else {
            if (prevChar == ' ') {
                prevChar = c;
                accumulator = 1;
                continue;
            }

            sb.append("" + accumulator + prevChar);

            prevChar = c;
            accumulator = 1;
        }
    }

    if (accumulator &gt; 0) sb.append("" + accumulator + prevChar);

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Palindrome Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number/"/>
    <updated>2014-11-06T15:59:14+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/palindrome-number/">https://oj.leetcode.com/problems/palindrome-number/</a></p>

<pre><code>public boolean isPalindrome(int x) {
    if (x &lt; 0) return false;

    // get length of digit
    int carryLength = 1;
    while (x / carryLength &gt;= 10) {
        carryLength *= 10;
    }

    while (x &gt; 0) {
        // test if the first and the end digit is equal; if not, return false
        if (x / carryLength != x % 10) return false;

        x = x % carryLength / 10;    // get the new number without the first and the end digit
        carryLength /= 100;    // for cutting the first and the end digit, we need to shrink carry length by 2 times
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number/"/>
    <updated>2014-11-05T18:29:57+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number</id>
    <content type="html"><![CDATA[<p>原题链接：<a href="https://oj.leetcode.com/problems/valid-number/">https://oj.leetcode.com/problems/valid-number/</a></p>

<p>这道题主要是注意 &ldquo;+&rdquo;/&ldquo;&ndash;&rdquo;/&ldquo;e&rdquo;/&ldquo;E&rdquo;/&ldquo;.&rdquo; 的位置，遍历字符串，当遇到上述几种符号时就判断位置是否正确，不正确则退出遍历过程，正确则继续，遇到非数字则退出遍历过程。</p>

<pre><code>public boolean isNumber(String s) {
    if (s == null) {
        return false;
    }

    String str = s.trim();

    if (str.length() == 0) {
        return false;
    }

    boolean result = true;
    int length = str.length();
    char c;
    boolean exponentialExisted = false;
    boolean dotExisted = false;
    boolean quitLoop = false;
    boolean digitExisted = false;

    for (int i = 0; i &lt; length; i++) {
        c = str.charAt(i);

        if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
            digitExisted = true;
        } else {
            switch (c) {
                case '+':
                case '-':
                    if (i == length - 1 || i != 0 &amp;&amp; str.charAt(i - 1) != 'e' &amp;&amp; str.charAt(i - 1) != 'E') {
                        result = false;

                        quitLoop = true;
                    }

                    break;

                case 'e':
                case 'E':
                    if (exponentialExisted || i == 0 || i == length - 1 || ((str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9') &amp;&amp; str.charAt(i - 1) != '.') || !digitExisted) {
                        result = false;

                        quitLoop = true;
                    }

                    exponentialExisted = true;

                    break;

                case '.':
                    if (dotExisted || exponentialExisted || length == 1 || (i == length - 1 &amp;&amp; (str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9')) || 
                        (i == 0 &amp;&amp; ((str.charAt(i + 1) &lt; '0' || str.charAt(i + 1) &gt; '9') &amp;&amp; (str.charAt(i + 1) != 'e' &amp;&amp; str.charAt(i + 1) != 'E')))) {
                        result =  false;

                        quitLoop = true;
                    }

                    dotExisted = true;

                    break;

                default:
                    result = false;
                    quitLoop = true;
            }
        }

        if (quitLoop) break;
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
