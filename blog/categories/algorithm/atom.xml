<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2015-01-15T15:08:48+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Implement strStr()]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-implement-strstr/"/>
    <updated>2015-01-15T15:06:59+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-implement-strstr</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/implement-strstr/">https://oj.leetcode.com/problems/implement-strstr/</a></p>

<!-- more -->


<pre><code>public int strStr(String haystack, String needle) {
    if (haystack == null || needle == null) return -1;

    int haystackLen = haystack.length();
    int needleLen = needle.length();

    if (needleLen &gt; haystackLen) return -1;
    if (needleLen == 0) return 0;

    char[] haystackChars = haystack.toCharArray();
    char[] needleChars = needle.toCharArray();

    int index = 0;
    boolean found = false;
    while (index &lt; haystackLen) {
        if (haystackLen - index &lt; needleLen) {
            break;
        }

        int i = index;

        for (int j = 0; j &lt; needleLen; j++) {
            if (needleChars[j] != haystackChars[i]) {
                break;
            }

            i++;

            if (j == needleLen - 1) {
                found = true;
            }
        }

        if (found) {
            break;
        } else {
            index++;
        }
    }

    return found ? index : -1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Majority Element]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-majority-element/"/>
    <updated>2015-01-15T11:33:16+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-majority-element</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/majority-element/">https://oj.leetcode.com/problems/majority-element/</a></p>

<!-- more -->


<pre><code>public int majorityElement(int[] num) {
    Map&lt;Integer, Integer&gt; numToCount = new HashMap&lt;Integer, Integer&gt;();

    for (int i = 0, len = num.length; i &lt; len; i++) {
        if (numToCount.get(num[i]) != null) {
            numToCount.put(num[i], numToCount.get(num[i]) + 1);
        } else {
            numToCount.put(num[i], 1);
        }
    }

    int majorityNum = 0;
    int maxLen = Integer.MIN_VALUE;

    Iterator&lt;Integer&gt; itr = numToCount.keySet().iterator();

    while (itr.hasNext()) {
        int key = itr.next();
        if (numToCount.get(key) &gt; maxLen) {
            maxLen = numToCount.get(key);
            majorityNum = key;
        }
    }

    return majorityNum;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Min Stack]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack/"/>
    <updated>2015-01-15T10:04:07+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/min-stack/">https://oj.leetcode.com/problems/min-stack/</a></p>

<!-- more -->


<pre><code>class MinStack {
    private List&lt;Integer&gt; normalStack = new ArrayList&lt;Integer&gt;();
    private List&lt;Integer&gt; minNumStack = new ArrayList&lt;Integer&gt;();


    public void push(int x) {
        normalStack.add(x);

        if (minNumStack.isEmpty() || minNumStack.get(minNumStack.size() - 1) &gt;= x) {
            minNumStack.add(x);
        }
    }

    public void pop() {
        if (normalStack.isEmpty()) return;

        int x = normalStack.get(normalStack.size() - 1);
        normalStack.remove(normalStack.size() - 1);

        if (!minNumStack.isEmpty() &amp;&amp; x == minNumStack.get(minNumStack.size() - 1)) {
            minNumStack.remove(minNumStack.size() - 1);
        }
    }

    public int top() {
        if (normalStack.isEmpty()) return 0;

        return normalStack.get(normalStack.size() - 1);
    }

    public int getMin() {
        if (minNumStack.isEmpty()) return 0;

        return minNumStack.get(minNumStack.size() - 1);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Minimum Path Sum]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum/"/>
    <updated>2014-12-08T11:08:51+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/minimum-path-sum/">https://oj.leetcode.com/problems/minimum-path-sum/</a></p>

<!-- more -->


<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null || grid.length == 0) return 0;

    int rows = grid.length;
    int cols = grid[0].length;
    int[] res = new int[cols];
    res[0] = grid[0][0];

    for (int i = 1; i &lt; cols; i++) {
        res[i] = res[i - 1] + grid[0][i];
    }

    for (int i = 1; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            int top = res[j];
            int left = j == 0 ? Integer.MAX_VALUE : res[j - 1];
            res[j] = Math.min(top, left) + grid[i][j];
        }
    }

    return res[cols - 1];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Convert Sorted Array to Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree/"/>
    <updated>2014-12-05T10:56:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num == null || num.length == 0) return null;

    List&lt;Integer&gt; cursor = new ArrayList&lt;Integer&gt;(1);
    cursor.add(0);

    return sortedArrayToBSTHelper(num, 0, num.length - 1, cursor);
}

public TreeNode sortedArrayToBSTHelper(int[] num, int low, int high, List&lt;Integer&gt; cursor) {
    if (low &gt; high) return null;

    int mid = (low + high) / 2;

    TreeNode left = sortedArrayToBSTHelper(num, low, mid - 1, cursor);

    TreeNode root = new TreeNode(num[cursor.get(0)]);
    root.left = left;

    cursor.set(0, cursor.get(0) + 1);

    TreeNode right = sortedArrayToBSTHelper(num, mid + 1, high, cursor);
    root.right = right;

    return root;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
