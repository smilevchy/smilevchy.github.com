<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-19T15:23:14+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Level Order Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal/"/>
    <updated>2014-11-19T15:22:05+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/">https://oj.leetcode.com/problems/binary-tree-level-order-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    if (root == null) return new ArrayList&lt;List&lt;Integer&gt;&gt;();

    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;();

    row.add(root.val);
    result.add(row);

    row = new ArrayList&lt;Integer&gt;();

    List&lt;List&lt;Integer&gt;&gt; leftList = null;
    if (root.left != null) {
        row.add(root.left.val);
        leftList = levelOrder(root.left);
    }

    List&lt;List&lt;Integer&gt;&gt; rightList = null;
    if (root.right != null) {
        row.add(root.right.val);
        rightList = levelOrder(root.right);
    }

    if (row.size() &gt; 0) {
        result.add(row);
    }

    if (leftList != null) {
        leftList = leftList.subList(1, leftList.size());
    }

    if (rightList != null) {
        rightList = rightList.subList(1, rightList.size());
    }

    int i = 0;
    int leftSize = leftList != null ? leftList.size() : 0;
    int rightSize = rightList != null ? rightList.size() : 0;

    for (; i &lt; leftSize; i++) {
        row = new ArrayList&lt;Integer&gt;();

        row.addAll(leftList.get(i));
        if (i &lt; rightSize) row.addAll(rightList.get(i)); 

        result.add(row);
    }
    for (; i &lt; rightSize; i++) {
        row = new ArrayList&lt;Integer&gt;();

        row.addAll(rightList.get(i));

        result.add(row);
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Balanced Binary Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/18/leetcode-balanced-binary-tree/"/>
    <updated>2014-11-18T11:36:33+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/18/leetcode-balanced-binary-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/balanced-binary-tree/">https://oj.leetcode.com/problems/balanced-binary-tree/</a></p>

<!-- more -->


<pre><code>public boolean isBalanced(TreeNode root) {
    if (root == null) return true;

    int left = maxDepth(root.left);
    int right = maxDepth(root.right);

    if (Math.abs(left - right) &gt; 1) {
        return false;
    }

    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;

    if (root.left == null &amp;&amp; root.right == null) {
        return 1;
    }

    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Maximum Depth of Binary Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/18/leetcode-maximum-depth-of-binary-tree/"/>
    <updated>2014-11-18T10:39:00+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/18/leetcode-maximum-depth-of-binary-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/</a></p>

<!-- more -->


<pre><code>public int maxDepth(TreeNode root) {
    if (root == null) return 0;

    if (root.left == null &amp;&amp; root.right == null) {
        return 1;
    }

    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Minimum Depth of Binary Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/18/leetcode-minimum-depth-of-binary-tree/"/>
    <updated>2014-11-18T10:30:14+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/18/leetcode-minimum-depth-of-binary-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/</a></p>

<!-- more -->


<pre><code>public int minDepth(TreeNode root) {
    if (root == null) return 0;

    if (root.left == null &amp;&amp; root.right == null) {
        return 1;
    }  else if (root.left != null &amp;&amp; root.right != null) {
        return Math.min(minDepth(root.left) + 1, minDepth(root.right) + 1);
    } else if (root.left != null) {
        return minDepth(root.left) + 1;
    } else {
        return minDepth(root.right) + 1;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Pascal's Triangle II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/18/leetcode-pascals-triangle-ii/"/>
    <updated>2014-11-18T10:11:53+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/18/leetcode-pascals-triangle-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/pascals-triangle-ii/">https://oj.leetcode.com/problems/pascals-triangle-ii/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; getRow(int rowIndex) {
    if (rowIndex &lt; 0) return new ArrayList&lt;Integer&gt;();

    List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(rowIndex + 1);

    if (rowIndex == 0) {
        row.add(1);
    } else {
        List&lt;Integer&gt; upRow = getRow(rowIndex - 1);

        for (int i = 0; i &lt;= rowIndex; i++) {
            if (i == 0 || i == rowIndex) {
                row.add(1);
            } else {
                row.add(upRow.get(i - 1) + upRow.get(i));
            }
        }
    }

    return row;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
