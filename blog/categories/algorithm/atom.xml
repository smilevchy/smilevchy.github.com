<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-12-02T11:07:08+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Evaluate Reverse Polish Notation]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation/"/>
    <updated>2014-12-02T11:05:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>

<!-- more -->


<pre><code>public int evalRPN(String[] tokens) {
    if (tokens == null || tokens.length == 0) return 0;

    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
    int result = 0;
    String ele = null;

    for (int i = 0, len = tokens.length; i &lt; len; i++) {
        ele = tokens[i];

        if ("+".equals(ele) || "-".equals(ele) || "*".equals(ele) || "/".equals(ele)) {
            if (stack.isEmpty()) return result;
            Integer right = stack.pop();

            if (stack.isEmpty()) return result;
            Integer left = stack.pop();

            if ("+".equals(ele)) {
                stack.push(left + right);                   
            } else if ("-".equals(ele)) {
                stack.push(left - right);
            } else if ("*".equals(ele)) {
                stack.push(left * right);
            } else if ("/".equals(ele)) {
                stack.push(left / right);
            }
        } else {
            stack.push(Integer.valueOf(ele));
        }
    }

    if (!stack.isEmpty()) result = Integer.valueOf(stack.pop());

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/01/leetcode-single-number-ii/"/>
    <updated>2014-12-01T11:17:40+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/01/leetcode-single-number-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number-ii/">https://oj.leetcode.com/problems/single-number-ii/</a></p>

<!-- more -->


<p></p>

<pre><code>public int singleNumberII(int[] A) {
    if (A == null || A.length == 0) return 0;

    // the solving key is to regard the number as binary number, not decimal number,
    // so when a num exists 'n' times , the bits of it will multiply 'n' time too.

    int len = A.length;
    int[] digits = new int[32];

    for (int i = 0; i &lt; 32; i++) {
        for (int j = 0; j &lt; len; j++) {
            digits[i] += A[j] &gt;&gt; i &amp; 1;    // get the i-th bit of every number of A
        }
    }

    int result = 0;

    for (int i = 0; i &lt; 32; i++) {
        result += digits[i] % 3 &lt;&lt; i;
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Maximum Subarray]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/01/leetcode-maximum-subarray/"/>
    <updated>2014-12-01T10:21:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/01/leetcode-maximum-subarray</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/maximum-subarray/">https://oj.leetcode.com/problems/maximum-subarray/</a></p>

<!-- more -->


<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) return 0;

    int localMax = A[0];
    int globalMax = A[0];

    for (int i = 1, len = A.length; i &lt; len; i++) {
        localMax = Math.max(A[i], localMax + A[i]);
        globalMax = Math.max(localMax, globalMax);
    }

    return globalMax;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Search Insert Position]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/25/leetcode-search-insert-position/"/>
    <updated>2014-11-25T17:45:19+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/25/leetcode-search-insert-position</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/search-insert-position/">https://oj.leetcode.com/problems/search-insert-position/</a></p>

<!-- more -->


<pre><code>public int searchInsert(int[] A, int target) {
    if (A == null || A.length == 0) return 0;

    int length = A.length;
    int low = 0;
    int high = length - 1;
    int mid = 0;

    while (low &lt;= high) {
        mid = (low + high) / 2;

        if (A[mid] == target) {
            return mid;
        } else if (A[mid] &lt; target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return low;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_ZigZag Conversion]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/25/leetcode-zigzag-conversion/"/>
    <updated>2014-11-25T15:20:09+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/25/leetcode-zigzag-conversion</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/zigzag-conversion/">https://oj.leetcode.com/problems/zigzag-conversion/</a></p>

<!-- more -->


<pre><code>public String convert(String s, int nRows) {
    if (s == null || nRows &lt;= 1) return s;

    StringBuilder sb = new StringBuilder();
    int length = s.length();
    int span = 2 * nRows - 2;

    for (int i = 0; i &lt; nRows; i++) {
        for (int j = i; j &lt; length; j += span) {
            sb.append(s.charAt(j));

            if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; j + span - 2 * i &lt; length) {
                sb.append(s.charAt(j + span - 2 * i));
            }
        }
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
</feed>
