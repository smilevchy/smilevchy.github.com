<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-12-04T13:02:03+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Set Matrix Zeroes]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes/"/>
    <updated>2014-12-04T12:03:59+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/set-matrix-zeroes/">https://oj.leetcode.com/problems/set-matrix-zeroes/</a></p>

<!-- more -->


<pre><code>public void setZeroes(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean[] row = new boolean[m];
    boolean[] col = new boolean[n];

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                row[i] = true;
                col[j] = true;
            }
        }
    }

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (row[i] || col[j]) {
                matrix[i][j] = 0;                   
            }
        }
    }
}

public void setZeroesV2(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean firstRowZero = false;
    boolean firstColZero = false;

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;

                if (i == 0) firstRowZero = true;
                if (j == 0) firstColZero = true;
            }
        }
    }

    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            if (matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j] = 0;
        }
    }

    if (firstRowZero) {
        for (int i = 0; i &lt; n; i++) matrix[0][i] = 0;
    }

    if (firstColZero) {
        for (int i = 0; i &lt; m; i++) matrix[i][0] = 0;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Validate Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-validate-binary-search-tree/"/>
    <updated>2014-12-04T11:04:02+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-validate-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/validate-binary-search-tree/">https://oj.leetcode.com/problems/validate-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public boolean isValidBST(TreeNode root) {
    if (root == null) return true;

    LinkedList&lt;TreeNode&gt; inorderNodes = new LinkedList&lt;TreeNode&gt;();
    List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();

    while (root != null || !inorderNodes.isEmpty()) {
        if (root != null) {
            inorderNodes.push(root);
            root = root.left;
        } else {
            TreeNode top = inorderNodes.pop(); 
            vals.add(top.val);
            root = top.right;
        }
    }

    for (int i = 1, s = vals.size(); i &lt; s; i++) {
        if (vals.get(i) &lt;= vals.get(i -1)) return false;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Permutations]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations/"/>
    <updated>2014-12-03T10:48:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/permutations/">https://oj.leetcode.com/problems/permutations/</a></p>

<!-- more -->


<p></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    if (num == null || num.length == 0) return result;

    List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;();
    for (int e : num) {
        first.add(e);
    }
    result.add(first);

    for (int pos = 0, len = num.length; pos &lt; len; pos++) {
        for (int i = 0, s = result.size(); i &lt; s; i++) {
            for (int j = pos + 1; j &lt; len; j++) {
                List&lt;Integer&gt; ele = new ArrayList&lt;Integer&gt;(result.get(i));                  

                ele.set(j, ele.get(j) ^ ele.get(pos));
                ele.set(pos, ele.get(j) ^ ele.get(pos));
                ele.set(j, ele.get(j) ^ ele.get(pos));

                result.add(ele);
            }
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Rotate Image]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image/"/>
    <updated>2014-12-02T15:04:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/rotate-image/">https://oj.leetcode.com/problems/rotate-image/</a></p>

<!-- more -->


<pre><code>/*
 * [1, 1, 1, 1, 1]
 * [1, 2, 2, 2, 1]
 * [1, 2, 3, 2, 1]
 * [1, 2, 2, 2, 1]
 * [1, 1, 1, 1, 1]
 * 
 * Like shown above, take the 2-dim array as it has some layers wrapping each other, layer 1 wraps layer 2, layer 2 wraps layer 3......
 * For each layer, we can divide it into four blocks : top row, right col, bottom row, left col.
 * What we have to do is : move top row to right col, right col to bottom row, bottom row to left col, left col to top row.
 * And, we do this for times of numbers of layers(matrix's length / 2).  
 */
public void rotate(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;

    int matrixSize = matrix.length;
    int layerNum = matrixSize / 2;

    for (int i = 0; i &lt; layerNum; i++) {
        for (int low = i, high = matrixSize - i - 1; low &lt; high; low++) {
            int temp = matrix[i][low];

            // move left col to top row
            matrix[i][low] = matrix[matrixSize - low - 1][i];

            // move bottom row to left col
            matrix[matrixSize - low - 1][i] = matrix[high][matrixSize - low - 1];

            // move right col to bottom row
            matrix[high][matrixSize - low - 1] = matrix[low][high];

            // move top row to right col
            matrix[low][high] = temp; 
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Evaluate Reverse Polish Notation]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation/"/>
    <updated>2014-12-02T11:05:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>

<!-- more -->


<pre><code>public int evalRPN(String[] tokens) {
    if (tokens == null || tokens.length == 0) return 0;

    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
    int result = 0;
    String ele = null;

    for (int i = 0, len = tokens.length; i &lt; len; i++) {
        ele = tokens[i];

        if ("+".equals(ele) || "-".equals(ele) || "*".equals(ele) || "/".equals(ele)) {
            if (stack.isEmpty()) return result;
            Integer right = stack.pop();

            if (stack.isEmpty()) return result;
            Integer left = stack.pop();

            if ("+".equals(ele)) {
                stack.push(left + right);                   
            } else if ("-".equals(ele)) {
                stack.push(left - right);
            } else if ("*".equals(ele)) {
                stack.push(left * right);
            } else if ("/".equals(ele)) {
                stack.push(left / right);
            }
        } else {
            stack.push(Integer.valueOf(ele));
        }
    }

    if (!stack.isEmpty()) result = Integer.valueOf(stack.pop());

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
