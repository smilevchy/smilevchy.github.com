<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-24T13:27:46+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Partition List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list/"/>
    <updated>2014-11-24T11:20:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/partition-list/">https://oj.leetcode.com/problems/partition-list/</a></p>

<!-- more -->


<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) return null;

    ListNode lastSmallerNumCursor = null;
    ListNode prev = null;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            if (prev == null) {
                lastSmallerNumCursor = cur;
                cur = cur.next;

                continue;
            }

            prev.next = cur.next;
            if (lastSmallerNumCursor == null) {
                cur.next = head;
                head = cur;
            } else {
                cur.next = lastSmallerNumCursor.next;
                lastSmallerNumCursor.next = cur;
            }

            lastSmallerNumCursor = cur;
        }

        prev = cur;
        cur = cur.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii/"/>
    <updated>2014-11-24T10:40:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">https://oj.leetcode.com/problems/linked-list-cycle-ii/</a></p>

<!-- more -->


<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head;
    boolean hasCycle = false;

    while (quickCursor != null &amp;&amp; quickCursor.next!=null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor == quickCursor) {
            hasCycle = true;

            break;
        }
    }

    if (!hasCycle) return null;

    // reset either reference to head
    slowCursor = head;

    // iterate again until both references meet again, then getting the wanted node
    while (slowCursor != quickCursor) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next;
    }

    return slowCursor;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle/"/>
    <updated>2014-11-21T16:17:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle/">https://oj.leetcode.com/problems/linked-list-cycle/</a></p>

<!-- more -->


<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null) return false;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor != null &amp;&amp; quickCursor != null &amp;&amp; (quickCursor == slowCursor || quickCursor.next == slowCursor)) {
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number/"/>
    <updated>2014-11-21T15:23:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number/">https://oj.leetcode.com/problems/single-number/</a></p>

<!-- more -->


<pre><code>PS: 利用异或运算可以用来加解密.

public int singleNumber(int[] A) {
    int num = 0;

    for (int i = 0, length = A.length; i &lt; length; i++) {
        num ^= A[i];
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Length of Last Word]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word/"/>
    <updated>2014-11-21T15:07:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/length-of-last-word/">https://oj.leetcode.com/problems/length-of-last-word/</a></p>

<!-- more -->


<pre><code>public int lengthOfLastWord(String s) {
    if (s == null) return 0;

    int lengthOfLastWord = 0;
    boolean meetSpace = false;
    char c;

    for (int i = 0, length = s.length(); i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case ' ':
                meetSpace = true;

                break;

            default:
                if (meetSpace) {
                    lengthOfLastWord = 0;
                    lengthOfLastWord++;
                    meetSpace = false;
                } else {
                    lengthOfLastWord++;
                }

                break;
        }
    }

    return lengthOfLastWord;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
