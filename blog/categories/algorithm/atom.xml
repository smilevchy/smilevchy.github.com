<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2015-01-15T10:06:33+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Min Stack]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack/"/>
    <updated>2015-01-15T10:04:07+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/min-stack/">https://oj.leetcode.com/problems/min-stack/</a></p>

<!-- more -->


<pre><code>class MinStack {
    private List&lt;Integer&gt; normalStack = new ArrayList&lt;Integer&gt;();
    private List&lt;Integer&gt; minNumStack = new ArrayList&lt;Integer&gt;();


    public void push(int x) {
        normalStack.add(x);

        if (minNumStack.isEmpty() || minNumStack.get(minNumStack.size() - 1) &gt;= x) {
            minNumStack.add(x);
        }
    }

    public void pop() {
        if (normalStack.isEmpty()) return;

        int x = normalStack.get(normalStack.size() - 1);
        normalStack.remove(normalStack.size() - 1);

        if (!minNumStack.isEmpty() &amp;&amp; x == minNumStack.get(minNumStack.size() - 1)) {
            minNumStack.remove(minNumStack.size() - 1);
        }
    }

    public int top() {
        if (normalStack.isEmpty()) return 0;

        return normalStack.get(normalStack.size() - 1);
    }

    public int getMin() {
        if (minNumStack.isEmpty()) return 0;

        return minNumStack.get(minNumStack.size() - 1);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Minimum Path Sum]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum/"/>
    <updated>2014-12-08T11:08:51+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/minimum-path-sum/">https://oj.leetcode.com/problems/minimum-path-sum/</a></p>

<!-- more -->


<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null || grid.length == 0) return 0;

    int rows = grid.length;
    int cols = grid[0].length;
    int[] res = new int[cols];
    res[0] = grid[0][0];

    for (int i = 1; i &lt; cols; i++) {
        res[i] = res[i - 1] + grid[0][i];
    }

    for (int i = 1; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            int top = res[j];
            int left = j == 0 ? Integer.MAX_VALUE : res[j - 1];
            res[j] = Math.min(top, left) + grid[i][j];
        }
    }

    return res[cols - 1];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Convert Sorted Array to Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree/"/>
    <updated>2014-12-05T10:56:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num == null || num.length == 0) return null;

    List&lt;Integer&gt; cursor = new ArrayList&lt;Integer&gt;(1);
    cursor.add(0);

    return sortedArrayToBSTHelper(num, 0, num.length - 1, cursor);
}

public TreeNode sortedArrayToBSTHelper(int[] num, int low, int high, List&lt;Integer&gt; cursor) {
    if (low &gt; high) return null;

    int mid = (low + high) / 2;

    TreeNode left = sortedArrayToBSTHelper(num, low, mid - 1, cursor);

    TreeNode root = new TreeNode(num[cursor.get(0)]);
    root.left = left;

    cursor.set(0, cursor.get(0) + 1);

    TreeNode right = sortedArrayToBSTHelper(num, mid + 1, high, cursor);
    root.right = right;

    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-find-minimum-in-rotated-sorted-array/"/>
    <updated>2014-12-04T14:33:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-find-minimum-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/">https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p>

<!-- more -->


<pre><code>public int findMin(int[] num) {
    if (num == null || num.length == 0) return 0;

    return findMinHelper(num, 0, num.length - 1);
}

public int findMinHelper(int[] num, int low, int high) {
    if (low &gt; high) return 0;

    if (high - low &lt;= 1) return Math.min(num[low], num[high]);

    int mid = (low + high) / 2;
    int result = Math.min(num[mid], Math.min(findMinHelper(num, low, mid - 1), findMinHelper(num, mid + 1, high)));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Set Matrix Zeroes]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes/"/>
    <updated>2014-12-04T12:03:59+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/set-matrix-zeroes/">https://oj.leetcode.com/problems/set-matrix-zeroes/</a></p>

<!-- more -->


<pre><code>public void setZeroes(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean[] row = new boolean[m];
    boolean[] col = new boolean[n];

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                row[i] = true;
                col[j] = true;
            }
        }
    }

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (row[i] || col[j]) {
                matrix[i][j] = 0;                   
            }
        }
    }
}

public void setZeroesV2(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean firstRowZero = false;
    boolean firstColZero = false;

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;

                if (i == 0) firstRowZero = true;
                if (j == 0) firstColZero = true;
            }
        }
    }

    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            if (matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j] = 0;
        }
    }

    if (firstRowZero) {
        for (int i = 0; i &lt; n; i++) matrix[0][i] = 0;
    }

    if (firstColZero) {
        for (int i = 0; i &lt; m; i++) matrix[i][0] = 0;
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
