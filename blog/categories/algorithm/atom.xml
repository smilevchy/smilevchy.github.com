<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-21T11:28:05+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Inorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal/"/>
    <updated>2014-11-21T11:26:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(inorderTraversal(root.left));
    result.add(root.val);
    result.addAll(inorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Preorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal/"/>
    <updated>2014-11-20T18:17:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">https://oj.leetcode.com/problems/binary-tree-preorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            result.add(root.val);
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.add(root.val);
    result.addAll(preorderTraversal(root.left));
    result.addAll(preorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Sort List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list/"/>
    <updated>2014-11-20T17:51:47+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/sort-list/">https://oj.leetcode.com/problems/sort-list/</a></p>

<!-- more -->


<pre><code>public ListNode sortList(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return head;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;
    }

    ListNode headRight = slowCursor.next;
    ListNode headLeft = head;
    slowCursor.next = null;

    return mergeTwoLists(sortList(headLeft), sortList(headRight));
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode helper = new ListNode(0);
    helper.next = l1;
    ListNode pre = helper;

    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            l1 = l1.next;
        } else {
            ListNode next = l2.next;
            l2.next = pre.next;
            pre.next = l2;
            l2 = next;
        }

        pre = pre.next;
    }

    if (l2 != null) {
        pre.next = l2;
    }

    return helper.next;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Merge Two Sorted Lists]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-merge-two-sorted-lists/"/>
    <updated>2014-11-20T15:41:09+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-merge-two-sorted-lists</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/merge-two-sorted-lists/">https://oj.leetcode.com/problems/merge-two-sorted-lists/</a></p>

<!-- more -->


<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    ListNode cursorLeft = l1;
    ListNode cursorRight = l2;
    ListNode prevLeft = null;

    while (cursorRight != null) {
        while (cursorLeft != null &amp;&amp; cursorLeft.val &lt;= cursorRight.val) {
            prevLeft = cursorLeft;
            cursorLeft = cursorLeft.next;
        }

        if (prevLeft == null) {
            l2 = cursorRight.next;
            cursorRight.next = l1;
            l1 = cursorRight;
            cursorRight = l2;
        } else if (cursorLeft == null) {
            l2 = cursorRight.next;
            cursorRight.next = null;
            prevLeft.next = cursorRight;
            cursorRight = l2;
        } else {
            l2 = cursorRight.next;
            cursorRight.next = cursorLeft;
            prevLeft.next = cursorRight;
            cursorRight = l2;
        }

        cursorLeft = l1;
    }

    return l1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Add Binary]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-add-binary/"/>
    <updated>2014-11-20T14:51:16+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-add-binary</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/add-binary/">https://oj.leetcode.com/problems/add-binary/</a></p>

<!-- more -->


<pre><code>public String addBinary(String a, String b) {
    if (a == null &amp;&amp; b == null) return null;

    StringBuilder sb = new StringBuilder(a);

    int i = sb.length() - 1;
    int j = b.length() - 1;
    int carry = 0;
    char ac;
    char bc;

    while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
        ac = sb.charAt(i);
        bc = b.charAt(j);

        sb.setCharAt(i, (char) ('0' + (ac - '0' + bc - '0' + carry) % 2));
        carry = (ac - '0' + bc - '0' + carry) / 2;

        i--;
        j--;
    }

    while (i &gt;= 0) {
        ac = sb.charAt(i);
        sb.setCharAt(i, (char) ('0' + (ac - '0' + carry) % 2));
        carry = (ac - '0' + carry) / 2;
        i--;
    }

    while (j &gt;= 0) {
        bc = b.charAt(j);
        sb.insert(0, (char) ('0' + (bc - '0' + carry) % 2));
        carry = (bc - '0' + carry) / 2;
        j--;
    }

    if (carry &gt; 0) {
        sb.insert(0, '1');
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
</feed>
