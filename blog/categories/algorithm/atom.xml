<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-24T17:02:47+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Convert Sorted List to Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-convert-sorted-list-to-binary-search-tree/"/>
    <updated>2014-11-24T17:01:36+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-convert-sorted-list-to-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public TreeNode sortedListToBST(ListNode head) {
    if (head == null) return null;

    ListNode cur = head;
    int size = 0;

    while (cur != null) {
        size++;
        cur = cur.next;
    }

    List&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;();
    list.add(head);
    TreeNode tree = sortedListToBSTHelper(list, 0, size - 1);

    return tree;
}

public TreeNode sortedListToBSTHelper(List&lt;ListNode&gt; list, int low, int high) {
    if (low &gt; high) return null;

    int mid = (low + high) / 2;

    TreeNode left = sortedListToBSTHelper(list, low, mid - 1);

    TreeNode root = new TreeNode(list.get(0).val);
    root.left = left;

    list.set(0, list.get(0).next);
    TreeNode right = sortedListToBSTHelper(list, mid + 1, high);
    root.right = right;

    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Flatten Binary Tree to Linked List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-flatten-binary-tree-to-linked-list/"/>
    <updated>2014-11-24T14:42:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-flatten-binary-tree-to-linked-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p>

<!-- more -->


<pre><code>public void flatten(TreeNode root) {
    if (root == null) return;

    List&lt;TreeNode&gt; pre = new ArrayList&lt;TreeNode&gt;(1);
    pre.add(null);
    flattenHelper(root, pre);
}

private void flattenHelper(TreeNode root, List&lt;TreeNode&gt; pre) {
    if (root == null) return;

    if (pre.get(0) != null) {
        pre.get(0).left = null;
        pre.get(0).right = root;
    }

    TreeNode rootRight = root.right;
    pre.set(0, root);
    flattenHelper(root.left, pre);
    flattenHelper(rootRight, pre);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Partition List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list/"/>
    <updated>2014-11-24T11:20:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/partition-list/">https://oj.leetcode.com/problems/partition-list/</a></p>

<!-- more -->


<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) return null;

    ListNode lastSmallerNumCursor = null;
    ListNode prev = null;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            if (prev == null) {
                lastSmallerNumCursor = cur;
                cur = cur.next;

                continue;
            }

            prev.next = cur.next;
            if (lastSmallerNumCursor == null) {
                cur.next = head;
                head = cur;
            } else {
                cur.next = lastSmallerNumCursor.next;
                lastSmallerNumCursor.next = cur;
            }

            lastSmallerNumCursor = cur;
        }

        prev = cur;
        cur = cur.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii/"/>
    <updated>2014-11-24T10:40:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">https://oj.leetcode.com/problems/linked-list-cycle-ii/</a></p>

<!-- more -->


<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head;
    boolean hasCycle = false;

    while (quickCursor != null &amp;&amp; quickCursor.next!=null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor == quickCursor) {
            hasCycle = true;

            break;
        }
    }

    if (!hasCycle) return null;

    // reset either reference to head
    slowCursor = head;

    // iterate again until both references meet again, then getting the wanted node
    while (slowCursor != quickCursor) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next;
    }

    return slowCursor;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle/"/>
    <updated>2014-11-21T16:17:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle/">https://oj.leetcode.com/problems/linked-list-cycle/</a></p>

<!-- more -->


<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null) return false;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor != null &amp;&amp; quickCursor != null &amp;&amp; (quickCursor == slowCursor || quickCursor.next == slowCursor)) {
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
