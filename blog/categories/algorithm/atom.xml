<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-20T10:25:44+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Duplicates From Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-duplicates-from-sorted-array/"/>
    <updated>2014-11-20T10:24:22+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-duplicates-from-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>

<!-- more -->


<pre><code>public int removeDuplicates(int[] A) {
    if (A == null || A.length == 0) return 0;

    int index = 1;

    for (int i = 1, length = A.length; i &lt; length; i++) {
        if (A[i] != A[i - 1]) {
            A[index] = A[i];
            index++;
        }
    }

    return index;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Parentheses]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-valid-parentheses/"/>
    <updated>2014-11-19T18:19:46+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-valid-parentheses</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/valid-parentheses/">https://oj.leetcode.com/problems/valid-parentheses/</a></p>

<!-- more -->


<pre><code>public boolean isValid(String s) {
    if (s == null) return false;

    int length = s.length();
    char c;
    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

    for (int i = 0; i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case '(':
            case '{':
            case '[':
                stack.push(c);

                break;

            case ')':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '(') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            case '}':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '{') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            case ']':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '[') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            default:
                return false;
        }
    }

    if (!stack.isEmpty()) return false;

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Nth Node From End of List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-remove-nth-node-from-end-of-list/"/>
    <updated>2014-11-19T17:55:05+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-remove-nth-node-from-end-of-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>

<!-- more -->


<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null) return null;
    if (n == 0) return head;

    ListNode cursor = head;
    int size = 0;

    while (cursor != null) {
        cursor = cursor.next;
        size++;
    }

    cursor = head;
    int targetIndex = size - n;
    int cursorIndex = 0;
    ListNode prevNode = null;

    while (cursorIndex &lt; targetIndex) {
        prevNode = cursor;
        cursor = cursor.next;
        cursorIndex++;
    }

    if (prevNode == null) {
        head = cursor.next;
    } else {
        prevNode.next = cursor.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Merge Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-merge-sorted-array/"/>
    <updated>2014-11-19T17:00:17+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-merge-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/merge-sorted-array/">https://oj.leetcode.com/problems/merge-sorted-array/</a></p>

<!-- more -->


<pre><code>public void merge(int A[], int m, int B[], int n) {
    int size = m + n;
    int[] workspace = new int[size];

    int i = 0;
    int j = 0;
    int k = 0;

    while (i &lt; m &amp;&amp; j &lt; n) {
        if (A[i] &lt; B[j]) {
            workspace[k++] = A[i++];
        } else {
            workspace[k++] = B[j++];
        }
    }

    while (i &lt; m) {
        workspace[k++] = A[i++];
    }

    while (j &lt; n) {
        workspace[k++] = B[j++];
    }

    for (k = 0; k &lt; size; k++) {
        A[k] = workspace[k];
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Level Order Traversal II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal-ii/"/>
    <updated>2014-11-19T15:46:19+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p>

<!-- more -->


<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();

    if (root == null) return result;

    ArrayDeque&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();

    queue.offer(root);

    int lastNum = 1;
    int curNum = 0;
    List&lt;Integer&gt; row = new LinkedList&lt;Integer&gt;();

    while (!queue.isEmpty()) {
        lastNum--;

        TreeNode node = queue.poll();
        row.add(node.val);

        if (node.left != null) {
            curNum++;
            queue.offer(node.left);
        }

        if (node.right != null) {
            curNum++;
            queue.offer(node.right);
        }

        if (lastNum == 0) {
            result.addFirst(row);

            lastNum = curNum;
            curNum = 0;
            row = new LinkedList&lt;Integer&gt;();
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
