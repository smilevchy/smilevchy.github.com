<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shock | smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/blog/categories/shock/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-12-04T13:02:03+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trap of '0.1 + 0.2']]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2/"/>
    <updated>2014-11-22T10:45:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2</id>
    <content type="html"><![CDATA[<p>0.1 + 0.2 == ?</p>

<!-- more -->


<p>肯定是 0.3 啊。没错，在数学上的确是等于这个值。可是在计算机的世界里，由于浮点数目前还不能很精确地表示出来，所以这个数相加后的值会有偏差，不是你想象中的值 0.3。</p>

<p>为了看下相加后的值是多少，我分别用了 JavaScript\Java\Ruby\Python 测试，结果均得出值: 0.30000000000000004。
恩，这个大家都知道，浮点数运算一般都会有偏差的。
于是，我又测试了其他浮点数的相加，例如：0.1 + 0.1，0.2 + 0.2，0.1 + 0.4 &hellip;&hellip;
可是这些运算的返回值却和数学上的相加精确值一样，也就是说不是所有的浮点运算都会返回偏差值。</p>

<p>细思极恐下，平时有涉及到浮点运算时，如果单纯地用数学计算方式去运算，可能大部分情况下都不会出错，可是当遇到类似 0.1 + 0.2 的情况时，可能就会导致 bug 的出现了。</p>

<p>以后在涉及到浮点运算时，首先要看所用编程语言平台是否提供了相关浮点运算支持方案可用，没有的话则要避免想当然直接运算，应该把运算结果假设在一定误差范围内。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/13/todays-shocking/"/>
    <updated>2014-11-13T14:12:18+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/13/todays-shocking</id>
    <content type="html"><![CDATA[<p>Need to sort some values which are Chinese.</p>

<p>Firstly, I am thinking to find some third-party libraries to finish this job. However, this may seems to be &ldquo;heavy&rdquo; for project.</p>

<!-- more -->


<p>So I turn to find some useful algorithms.</p>

<p>On Internet, I have found some solutions about how to do this. But some of them look like too bulk. So wandering and wandering, at last I found a sulution which looks the best currently. Some guy say we can use javascript&rsquo;s function : localeCompare().</p>

<p>So, it is what I want to get. Currently it works well, but maybe it will have some drawbacks.</p>

<p>Anyhow, it is a work around now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/10/19/todays-shock/"/>
    <updated>2014-10-19T22:12:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/10/19/todays-shock</id>
    <content type="html"><![CDATA[<p>在看《Ruby 编程语言》时，看到一个概念，叫做 Shebang 注释。
一开始以为是那本书籍打印出错了，因为 ”Shebang“ 看起来怎么也不像英文单词，而且直觉上能发成中文的音。
但是还是觉得不对，所以就搜索了一下。</p>

<p>&ndash;_&ndash; 结果显示，维基百科上真的有叫 Shebang 的条目。
看了条目内容，才知道原来 Shebang 指的就是平常 unix shell 文件开头第一行的那句话（#!/bin/sh）的前两个字符。
而一般把形如 #!XXXXX 的语句叫做 Shebang 注释。</p>

<p>我真是孤陋寡闻&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/08/27/todays-shock/"/>
    <updated>2014-08-27T21:04:45+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/08/27/todays-shock</id>
    <content type="html"><![CDATA[<p>今天在阅读论文 &lt;Architectural Styles and the Design of Network-based Software Architectures&gt; 中，里面谈到了 HTTP 协议的定义。它明确指出了一个观点：“HTTP 并不是一种传输协议”。HTTP 并不是被设计为一种传输协议（transport protocol），它是一种转移协议（transfer protocol）。</p>

<!-- more -->


<p>这都是因为HTTP 在刚刚传入中国时被翻译成了“超文本传输协议”，然后大家都互相传播，造成了现在大家对 HTTP 的表述就是 “超文本传输协议”。</p>
]]></content>
  </entry>
  
</feed>
