<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-12-03T10:49:55+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Permutations]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations/"/>
    <updated>2014-12-03T10:48:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/permutations/">https://oj.leetcode.com/problems/permutations/</a></p>

<!-- more -->


<p></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    if (num == null || num.length == 0) return result;

    List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;();
    for (int e : num) {
        first.add(e);
    }
    result.add(first);

    for (int pos = 0, len = num.length; pos &lt; len; pos++) {
        for (int i = 0, s = result.size(); i &lt; s; i++) {
            for (int j = pos + 1; j &lt; len; j++) {
                List&lt;Integer&gt; ele = new ArrayList&lt;Integer&gt;(result.get(i));                  

                ele.set(j, ele.get(j) ^ ele.get(pos));
                ele.set(pos, ele.get(j) ^ ele.get(pos));
                ele.set(j, ele.get(j) ^ ele.get(pos));

                result.add(ele);
            }
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Rotate Image]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image/"/>
    <updated>2014-12-02T15:04:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/rotate-image/">https://oj.leetcode.com/problems/rotate-image/</a></p>

<!-- more -->


<pre><code>/*
 * [1, 1, 1, 1, 1]
 * [1, 2, 2, 2, 1]
 * [1, 2, 3, 2, 1]
 * [1, 2, 2, 2, 1]
 * [1, 1, 1, 1, 1]
 * 
 * Like shown above, take the 2-dim array as it has some layers wrapping each other, layer 1 wraps layer 2, layer 2 wraps layer 3......
 * For each layer, we can divide it into four blocks : top row, right col, bottom row, left col.
 * What we have to do is : move top row to right col, right col to bottom row, bottom row to left col, left col to top row.
 * And, we do this for times of numbers of layers(matrix's length / 2).  
 */
public void rotate(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;

    int matrixSize = matrix.length;
    int layerNum = matrixSize / 2;

    for (int i = 0; i &lt; layerNum; i++) {
        for (int low = i, high = matrixSize - i - 1; low &lt; high; low++) {
            int temp = matrix[i][low];

            // move left col to top row
            matrix[i][low] = matrix[matrixSize - low - 1][i];

            // move bottom row to left col
            matrix[matrixSize - low - 1][i] = matrix[high][matrixSize - low - 1];

            // move right col to bottom row
            matrix[high][matrixSize - low - 1] = matrix[low][high];

            // move top row to right col
            matrix[low][high] = temp; 
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Evaluate Reverse Polish Notation]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation/"/>
    <updated>2014-12-02T11:05:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>

<!-- more -->


<pre><code>public int evalRPN(String[] tokens) {
    if (tokens == null || tokens.length == 0) return 0;

    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
    int result = 0;
    String ele = null;

    for (int i = 0, len = tokens.length; i &lt; len; i++) {
        ele = tokens[i];

        if ("+".equals(ele) || "-".equals(ele) || "*".equals(ele) || "/".equals(ele)) {
            if (stack.isEmpty()) return result;
            Integer right = stack.pop();

            if (stack.isEmpty()) return result;
            Integer left = stack.pop();

            if ("+".equals(ele)) {
                stack.push(left + right);                   
            } else if ("-".equals(ele)) {
                stack.push(left - right);
            } else if ("*".equals(ele)) {
                stack.push(left * right);
            } else if ("/".equals(ele)) {
                stack.push(left / right);
            }
        } else {
            stack.push(Integer.valueOf(ele));
        }
    }

    if (!stack.isEmpty()) result = Integer.valueOf(stack.pop());

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/01/leetcode-single-number-ii/"/>
    <updated>2014-12-01T11:17:40+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/01/leetcode-single-number-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number-ii/">https://oj.leetcode.com/problems/single-number-ii/</a></p>

<!-- more -->


<p></p>

<pre><code>public int singleNumberII(int[] A) {
    if (A == null || A.length == 0) return 0;

    // the solving key is to regard the number as binary number, not decimal number,
    // so when a num exists 'n' times , the bits of it will multiply 'n' time too.

    int len = A.length;
    int[] digits = new int[32];

    for (int i = 0; i &lt; 32; i++) {
        for (int j = 0; j &lt; len; j++) {
            digits[i] += A[j] &gt;&gt; i &amp; 1;    // get the i-th bit of every number of A
        }
    }

    int result = 0;

    for (int i = 0; i &lt; 32; i++) {
        result += digits[i] % 3 &lt;&lt; i;
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Maximum Subarray]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/01/leetcode-maximum-subarray/"/>
    <updated>2014-12-01T10:21:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/01/leetcode-maximum-subarray</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/maximum-subarray/">https://oj.leetcode.com/problems/maximum-subarray/</a></p>

<!-- more -->


<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) return 0;

    int localMax = A[0];
    int globalMax = A[0];

    for (int i = 1, len = A.length; i &lt; len; i++) {
        localMax = Math.max(A[i], localMax + A[i]);
        globalMax = Math.max(localMax, globalMax);
    }

    return globalMax;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Search Insert Position]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/25/leetcode-search-insert-position/"/>
    <updated>2014-11-25T17:45:19+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/25/leetcode-search-insert-position</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/search-insert-position/">https://oj.leetcode.com/problems/search-insert-position/</a></p>

<!-- more -->


<pre><code>public int searchInsert(int[] A, int target) {
    if (A == null || A.length == 0) return 0;

    int length = A.length;
    int low = 0;
    int high = length - 1;
    int mid = 0;

    while (low &lt;= high) {
        mid = (low + high) / 2;

        if (A[mid] == target) {
            return mid;
        } else if (A[mid] &lt; target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return low;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_ZigZag Conversion]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/25/leetcode-zigzag-conversion/"/>
    <updated>2014-11-25T15:20:09+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/25/leetcode-zigzag-conversion</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/zigzag-conversion/">https://oj.leetcode.com/problems/zigzag-conversion/</a></p>

<!-- more -->


<pre><code>public String convert(String s, int nRows) {
    if (s == null || nRows &lt;= 1) return s;

    StringBuilder sb = new StringBuilder();
    int length = s.length();
    int span = 2 * nRows - 2;

    for (int i = 0; i &lt; nRows; i++) {
        for (int j = i; j &lt; length; j += span) {
            sb.append(s.charAt(j));

            if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; j + span - 2 * i &lt; length) {
                sb.append(s.charAt(j + span - 2 * i));
            }
        }
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Sqrt(x)]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-sqrt-x/"/>
    <updated>2014-11-24T18:04:08+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-sqrt-x</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/sqrtx/">https://oj.leetcode.com/problems/sqrtx/</a></p>

<!-- more -->


<pre><code>public int sqrt(int x) {
    if (x &lt; 0) return -1;
    if (x == 0) return 0;

    int low = 1;
    int high = x / 2 + 1;

    while (low &lt;= high) {
        int mid = (low + high) / 2;

        if (mid &lt;= x / mid &amp;&amp; x / (mid + 1) &lt; mid + 1) {
            return mid;
        } else if (mid &lt; x / mid) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return 0;
}
</code></pre>

<p>求平方根的方法还有 &ldquo;牛顿迭代法求平方根&rdquo;, &ldquo;卡马克快速平方根&#8221;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Convert Sorted List to Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-convert-sorted-list-to-binary-search-tree/"/>
    <updated>2014-11-24T17:01:36+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-convert-sorted-list-to-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public TreeNode sortedListToBST(ListNode head) {
    if (head == null) return null;

    ListNode cur = head;
    int size = 0;

    while (cur != null) {
        size++;
        cur = cur.next;
    }

    List&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;();
    list.add(head);
    TreeNode tree = sortedListToBSTHelper(list, 0, size - 1);

    return tree;
}

public TreeNode sortedListToBSTHelper(List&lt;ListNode&gt; list, int low, int high) {
    if (low &gt; high) return null;

    int mid = (low + high) / 2;

    TreeNode left = sortedListToBSTHelper(list, low, mid - 1);

    TreeNode root = new TreeNode(list.get(0).val);
    root.left = left;

    list.set(0, list.get(0).next);
    TreeNode right = sortedListToBSTHelper(list, mid + 1, high);
    root.right = right;

    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Flatten Binary Tree to Linked List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-flatten-binary-tree-to-linked-list/"/>
    <updated>2014-11-24T14:42:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-flatten-binary-tree-to-linked-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p>

<!-- more -->


<pre><code>public void flatten(TreeNode root) {
    if (root == null) return;

    List&lt;TreeNode&gt; pre = new ArrayList&lt;TreeNode&gt;(1);
    pre.add(null);
    flattenHelper(root, pre);
}

private void flattenHelper(TreeNode root, List&lt;TreeNode&gt; pre) {
    if (root == null) return;

    if (pre.get(0) != null) {
        pre.get(0).left = null;
        pre.get(0).right = root;
    }

    TreeNode rootRight = root.right;
    pre.set(0, root);
    flattenHelper(root.left, pre);
    flattenHelper(rootRight, pre);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Partition List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list/"/>
    <updated>2014-11-24T11:20:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/partition-list/">https://oj.leetcode.com/problems/partition-list/</a></p>

<!-- more -->


<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) return null;

    ListNode lastSmallerNumCursor = null;
    ListNode prev = null;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            if (prev == null) {
                lastSmallerNumCursor = cur;
                cur = cur.next;

                continue;
            }

            prev.next = cur.next;
            if (lastSmallerNumCursor == null) {
                cur.next = head;
                head = cur;
            } else {
                cur.next = lastSmallerNumCursor.next;
                lastSmallerNumCursor.next = cur;
            }

            lastSmallerNumCursor = cur;
        }

        prev = cur;
        cur = cur.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii/"/>
    <updated>2014-11-24T10:40:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">https://oj.leetcode.com/problems/linked-list-cycle-ii/</a></p>

<!-- more -->


<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head;
    boolean hasCycle = false;

    while (quickCursor != null &amp;&amp; quickCursor.next!=null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor == quickCursor) {
            hasCycle = true;

            break;
        }
    }

    if (!hasCycle) return null;

    // reset either reference to head
    slowCursor = head;

    // iterate again until both references meet again, then getting the wanted node
    while (slowCursor != quickCursor) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next;
    }

    return slowCursor;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trap of '0.1 + 0.2']]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2/"/>
    <updated>2014-11-22T10:45:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2</id>
    <content type="html"><![CDATA[<p>0.1 + 0.2 == ?</p>

<!-- more -->


<p>肯定是 0.3 啊。没错，在数学上的确是等于这个值。可是在计算机的世界里，由于浮点数目前还不能很精确地表示出来，所以这个数相加后的值会有偏差，不是你想象中的值 0.3。</p>

<p>为了看下相加后的值是多少，我分别用了 JavaScript\Java\Ruby\Python 测试，结果均得出值: 0.30000000000000004。
恩，这个大家都知道，浮点数运算一般都会有偏差的。
于是，我又测试了其他浮点数的相加，例如：0.1 + 0.1，0.2 + 0.2，0.1 + 0.4 &hellip;&hellip;
可是这些运算的返回值却和数学上的相加精确值一样，也就是说不是所有的浮点运算都会返回偏差值。</p>

<p>细思极恐下，平时有涉及到浮点运算时，如果单纯地用数学计算方式去运算，可能大部分情况下都不会出错，可是当遇到类似 0.1 + 0.2 的情况时，可能就会导致 bug 的出现了。</p>

<p>以后在涉及到浮点运算时，首先要看所用编程语言平台是否提供了相关浮点运算支持方案可用，没有的话则要避免想当然直接运算，应该把运算结果假设在一定误差范围内。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle/"/>
    <updated>2014-11-21T16:17:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle/">https://oj.leetcode.com/problems/linked-list-cycle/</a></p>

<!-- more -->


<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null) return false;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor != null &amp;&amp; quickCursor != null &amp;&amp; (quickCursor == slowCursor || quickCursor.next == slowCursor)) {
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number/"/>
    <updated>2014-11-21T15:23:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number/">https://oj.leetcode.com/problems/single-number/</a></p>

<!-- more -->


<pre><code>PS: 利用异或运算可以用来加解密.

public int singleNumber(int[] A) {
    int num = 0;

    for (int i = 0, length = A.length; i &lt; length; i++) {
        num ^= A[i];
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Length of Last Word]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word/"/>
    <updated>2014-11-21T15:07:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/length-of-last-word/">https://oj.leetcode.com/problems/length-of-last-word/</a></p>

<!-- more -->


<pre><code>public int lengthOfLastWord(String s) {
    if (s == null) return 0;

    int lengthOfLastWord = 0;
    boolean meetSpace = false;
    char c;

    for (int i = 0, length = s.length(); i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case ' ':
                meetSpace = true;

                break;

            default:
                if (meetSpace) {
                    lengthOfLastWord = 0;
                    lengthOfLastWord++;
                    meetSpace = false;
                } else {
                    lengthOfLastWord++;
                }

                break;
        }
    }

    return lengthOfLastWord;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Postorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal/"/>
    <updated>2014-11-21T14:44:22+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">https://oj.leetcode.com/problems/binary-tree-postorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
    TreeNode prev = null;

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            TreeNode peek = stack.peek();

            if (peek.right != null &amp;&amp; peek.right != prev) {
                root = peek.right;
            } else {
                stack.pop();
                result.add(peek.val);
                prev = peek;
            }
        }
    }

    return result;
}

public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Inorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal/"/>
    <updated>2014-11-21T11:26:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(inorderTraversal(root.left));
    result.add(root.val);
    result.addAll(inorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Preorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal/"/>
    <updated>2014-11-20T18:17:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">https://oj.leetcode.com/problems/binary-tree-preorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            result.add(root.val);
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.add(root.val);
    result.addAll(preorderTraversal(root.left));
    result.addAll(preorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Sort List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list/"/>
    <updated>2014-11-20T17:51:47+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/sort-list/">https://oj.leetcode.com/problems/sort-list/</a></p>

<!-- more -->


<pre><code>public ListNode sortList(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return head;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;
    }

    ListNode headRight = slowCursor.next;
    ListNode headLeft = head;
    slowCursor.next = null;

    return mergeTwoLists(sortList(headLeft), sortList(headRight));
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode helper = new ListNode(0);
    helper.next = l1;
    ListNode pre = helper;

    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            l1 = l1.next;
        } else {
            ListNode next = l2.next;
            l2.next = pre.next;
            pre.next = l2;
            l2 = next;
        }

        pre = pre.next;
    }

    if (l2 != null) {
        pre.next = l2;
    }

    return helper.next;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
