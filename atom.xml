<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-24T11:21:15+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Partition List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list/"/>
    <updated>2014-11-24T11:20:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-partition-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/partition-list/">https://oj.leetcode.com/problems/partition-list/</a></p>

<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) return null;

    ListNode lastSmallerNumCursor = null;
    ListNode prev = null;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            if (prev == null) {
                lastSmallerNumCursor = cur;
                cur = cur.next;

                continue;
            }

            prev.next = cur.next;
            if (lastSmallerNumCursor == null) {
                cur.next = head;
                head = cur;
            } else {
                cur.next = lastSmallerNumCursor.next;
                lastSmallerNumCursor.next = cur;
            }

            lastSmallerNumCursor = cur;
        }

        prev = cur;
        cur = cur.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii/"/>
    <updated>2014-11-24T10:40:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/24/leetcode-linked-list-cycle-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">https://oj.leetcode.com/problems/linked-list-cycle-ii/</a></p>

<!-- more -->


<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head;
    boolean hasCycle = false;

    while (quickCursor != null &amp;&amp; quickCursor.next!=null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor == quickCursor) {
            hasCycle = true;

            break;
        }
    }

    if (!hasCycle) return null;

    // reset either reference to head
    slowCursor = head;

    // iterate again until both references meet again, then getting the wanted node
    while (slowCursor != quickCursor) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next;
    }

    return slowCursor;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trap of '0.1 + 0.2']]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2/"/>
    <updated>2014-11-22T10:45:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/22/trap-of-0-dot-1-plus-0-dot-2</id>
    <content type="html"><![CDATA[<p>0.1 + 0.2 == ?</p>

<!-- more -->


<p>肯定是 0.3 啊。没错，在数学上的确是等于这个值。可是在计算机的世界里，由于浮点数目前还不能很精确地表示出来，所以这个数相加后的值会有偏差，不是你想象中的值 0.3。</p>

<p>为了看下相加后的值是多少，我分别用了 JavaScript\Java\Ruby\Python 测试，结果均得出值: 0.30000000000000004。
恩，这个大家都知道，浮点数运算一般都会有偏差的。
于是，我又测试了其他浮点数的相加，例如：0.1 + 0.1，0.2 + 0.2，0.1 + 0.4 &hellip;&hellip;
可是这些运算的返回值却和数学上的相加精确值一样，也就是说不是所有的浮点运算都会返回偏差值。</p>

<p>细思极恐下，平时有涉及到浮点运算时，如果单纯地用数学计算方式去运算，可能大部分情况下都不会出错，可是当遇到类似 0.1 + 0.2 的情况时，可能就会导致 bug 的出现了。</p>

<p>以后在涉及到浮点运算时，首先要看所用编程语言平台是否提供了相关浮点运算支持方案可用，没有的话则要避免想当然直接运算，应该把运算结果假设在一定误差范围内。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Linked List Cycle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle/"/>
    <updated>2014-11-21T16:17:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-linked-list-cycle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/linked-list-cycle/">https://oj.leetcode.com/problems/linked-list-cycle/</a></p>

<!-- more -->


<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null) return false;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;

        if (slowCursor != null &amp;&amp; quickCursor != null &amp;&amp; (quickCursor == slowCursor || quickCursor.next == slowCursor)) {
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Single Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number/"/>
    <updated>2014-11-21T15:23:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-single-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/single-number/">https://oj.leetcode.com/problems/single-number/</a></p>

<!-- more -->


<pre><code>PS: 利用异或运算可以用来加解密.

public int singleNumber(int[] A) {
    int num = 0;

    for (int i = 0, length = A.length; i &lt; length; i++) {
        num ^= A[i];
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Length of Last Word]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word/"/>
    <updated>2014-11-21T15:07:42+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-length-of-last-word</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/length-of-last-word/">https://oj.leetcode.com/problems/length-of-last-word/</a></p>

<!-- more -->


<pre><code>public int lengthOfLastWord(String s) {
    if (s == null) return 0;

    int lengthOfLastWord = 0;
    boolean meetSpace = false;
    char c;

    for (int i = 0, length = s.length(); i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case ' ':
                meetSpace = true;

                break;

            default:
                if (meetSpace) {
                    lengthOfLastWord = 0;
                    lengthOfLastWord++;
                    meetSpace = false;
                } else {
                    lengthOfLastWord++;
                }

                break;
        }
    }

    return lengthOfLastWord;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Postorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal/"/>
    <updated>2014-11-21T14:44:22+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-postorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">https://oj.leetcode.com/problems/binary-tree-postorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
    TreeNode prev = null;

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            TreeNode peek = stack.peek();

            if (peek.right != null &amp;&amp; peek.right != prev) {
                root = peek.right;
            } else {
                stack.pop();
                result.add(peek.val);
                prev = peek;
            }
        }
    }

    return result;
}

public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Inorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal/"/>
    <updated>2014-11-21T11:26:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/21/leetcode-binary-tree-inorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.addAll(inorderTraversal(root.left));
    result.add(root.val);
    result.addAll(inorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Preorder Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal/"/>
    <updated>2014-11-20T18:17:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-binary-tree-preorder-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">https://oj.leetcode.com/problems/binary-tree-preorder-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();

    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            result.add(root.val);
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            root = root.right;
        }
    }

    return result;
}

public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();

    if (root == null) return result;

    result.add(root.val);
    result.addAll(preorderTraversal(root.left));
    result.addAll(preorderTraversal(root.right));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Sort List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list/"/>
    <updated>2014-11-20T17:51:47+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-sort-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/sort-list/">https://oj.leetcode.com/problems/sort-list/</a></p>

<!-- more -->


<pre><code>public ListNode sortList(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return head;

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor.next != null &amp;&amp; quickCursor.next.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;
    }

    ListNode headRight = slowCursor.next;
    ListNode headLeft = head;
    slowCursor.next = null;

    return mergeTwoLists(sortList(headLeft), sortList(headRight));
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode helper = new ListNode(0);
    helper.next = l1;
    ListNode pre = helper;

    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            l1 = l1.next;
        } else {
            ListNode next = l2.next;
            l2.next = pre.next;
            pre.next = l2;
            l2 = next;
        }

        pre = pre.next;
    }

    if (l2 != null) {
        pre.next = l2;
    }

    return helper.next;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Merge Two Sorted Lists]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-merge-two-sorted-lists/"/>
    <updated>2014-11-20T15:41:09+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-merge-two-sorted-lists</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/merge-two-sorted-lists/">https://oj.leetcode.com/problems/merge-two-sorted-lists/</a></p>

<!-- more -->


<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    ListNode cursorLeft = l1;
    ListNode cursorRight = l2;
    ListNode prevLeft = null;

    while (cursorRight != null) {
        while (cursorLeft != null &amp;&amp; cursorLeft.val &lt;= cursorRight.val) {
            prevLeft = cursorLeft;
            cursorLeft = cursorLeft.next;
        }

        if (prevLeft == null) {
            l2 = cursorRight.next;
            cursorRight.next = l1;
            l1 = cursorRight;
            cursorRight = l2;
        } else if (cursorLeft == null) {
            l2 = cursorRight.next;
            cursorRight.next = null;
            prevLeft.next = cursorRight;
            cursorRight = l2;
        } else {
            l2 = cursorRight.next;
            cursorRight.next = cursorLeft;
            prevLeft.next = cursorRight;
            cursorRight = l2;
        }

        cursorLeft = l1;
    }

    return l1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Add Binary]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-add-binary/"/>
    <updated>2014-11-20T14:51:16+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-add-binary</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/add-binary/">https://oj.leetcode.com/problems/add-binary/</a></p>

<!-- more -->


<pre><code>public String addBinary(String a, String b) {
    if (a == null &amp;&amp; b == null) return null;

    StringBuilder sb = new StringBuilder(a);

    int i = sb.length() - 1;
    int j = b.length() - 1;
    int carry = 0;
    char ac;
    char bc;

    while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
        ac = sb.charAt(i);
        bc = b.charAt(j);

        sb.setCharAt(i, (char) ('0' + (ac - '0' + bc - '0' + carry) % 2));
        carry = (ac - '0' + bc - '0' + carry) / 2;

        i--;
        j--;
    }

    while (i &gt;= 0) {
        ac = sb.charAt(i);
        sb.setCharAt(i, (char) ('0' + (ac - '0' + carry) % 2));
        carry = (ac - '0' + carry) / 2;
        i--;
    }

    while (j &gt;= 0) {
        bc = b.charAt(j);
        sb.insert(0, (char) ('0' + (bc - '0' + carry) % 2));
        carry = (bc - '0' + carry) / 2;
        j--;
    }

    if (carry &gt; 0) {
        sb.insert(0, '1');
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Climbing Stairs]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-climbing-stairs/"/>
    <updated>2014-11-20T11:52:56+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-climbing-stairs</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/climbing-stairs/">https://oj.leetcode.com/problems/climbing-stairs/</a></p>

<!-- more -->


<pre><code>public int climbStairs(int n) {
    if (n &lt;= 0) return 0;

    if (n == 1) {
        return 1;
    } else if (n == 2) {
        return 2;
    }

    int a = 1;
    int b = 2;
    int c = 0;

    for (int i = 3; i &lt;= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }

    return c;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Element]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-element/"/>
    <updated>2014-11-20T11:19:55+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-element</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-element/">https://oj.leetcode.com/problems/remove-element/</a></p>

<!-- more -->


<pre><code>public int removeElement(int[] A, int elem) {
    if (A == null || A.length == 0) return 0;

    int length = A.length;
    int index = 0;

    for (int i = 0; i &lt; length; i++) {
        if (A[i] == elem) {
            A[index] = A[length - 1];
            i--;
            length--;
        } else {
            index++;
        }
    }

    return index;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Duplicates From Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-duplicates-from-sorted-array/"/>
    <updated>2014-11-20T10:24:22+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/20/leetcode-remove-duplicates-from-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>

<!-- more -->


<pre><code>public int removeDuplicates(int[] A) {
    if (A == null || A.length == 0) return 0;

    int index = 1;

    for (int i = 1, length = A.length; i &lt; length; i++) {
        if (A[i] != A[i - 1]) {
            A[index] = A[i];
            index++;
        }
    }

    return index;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Parentheses]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-valid-parentheses/"/>
    <updated>2014-11-19T18:19:46+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-valid-parentheses</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/valid-parentheses/">https://oj.leetcode.com/problems/valid-parentheses/</a></p>

<!-- more -->


<pre><code>public boolean isValid(String s) {
    if (s == null) return false;

    int length = s.length();
    char c;
    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

    for (int i = 0; i &lt; length; i++) {
        c = s.charAt(i);

        switch (c) {
            case '(':
            case '{':
            case '[':
                stack.push(c);

                break;

            case ')':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '(') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            case '}':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '{') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            case ']':
                try {
                    char prevChar = stack.pop();
                    if (prevChar != '[') return false;  
                } catch (Exception e) {
                    return false;
                }

                break;

            default:
                return false;
        }
    }

    if (!stack.isEmpty()) return false;

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Nth Node From End of List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-remove-nth-node-from-end-of-list/"/>
    <updated>2014-11-19T17:55:05+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-remove-nth-node-from-end-of-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>

<!-- more -->


<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null) return null;
    if (n == 0) return head;

    ListNode cursor = head;
    int size = 0;

    while (cursor != null) {
        cursor = cursor.next;
        size++;
    }

    cursor = head;
    int targetIndex = size - n;
    int cursorIndex = 0;
    ListNode prevNode = null;

    while (cursorIndex &lt; targetIndex) {
        prevNode = cursor;
        cursor = cursor.next;
        cursorIndex++;
    }

    if (prevNode == null) {
        head = cursor.next;
    } else {
        prevNode.next = cursor.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Merge Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-merge-sorted-array/"/>
    <updated>2014-11-19T17:00:17+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-merge-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/merge-sorted-array/">https://oj.leetcode.com/problems/merge-sorted-array/</a></p>

<!-- more -->


<pre><code>public void merge(int A[], int m, int B[], int n) {
    int size = m + n;
    int[] workspace = new int[size];

    int i = 0;
    int j = 0;
    int k = 0;

    while (i &lt; m &amp;&amp; j &lt; n) {
        if (A[i] &lt; B[j]) {
            workspace[k++] = A[i++];
        } else {
            workspace[k++] = B[j++];
        }
    }

    while (i &lt; m) {
        workspace[k++] = A[i++];
    }

    while (j &lt; n) {
        workspace[k++] = B[j++];
    }

    for (k = 0; k &lt; size; k++) {
        A[k] = workspace[k];
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Level Order Traversal II]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal-ii/"/>
    <updated>2014-11-19T15:46:19+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal-ii</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p>

<!-- more -->


<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();

    if (root == null) return result;

    ArrayDeque&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();

    queue.offer(root);

    int lastNum = 1;
    int curNum = 0;
    List&lt;Integer&gt; row = new LinkedList&lt;Integer&gt;();

    while (!queue.isEmpty()) {
        lastNum--;

        TreeNode node = queue.poll();
        row.add(node.val);

        if (node.left != null) {
            curNum++;
            queue.offer(node.left);
        }

        if (node.right != null) {
            curNum++;
            queue.offer(node.right);
        }

        if (lastNum == 0) {
            result.addFirst(row);

            lastNum = curNum;
            curNum = 0;
            row = new LinkedList&lt;Integer&gt;();
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Binary Tree Level Order Traversal]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal/"/>
    <updated>2014-11-19T15:22:05+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/19/leetcode-binary-tree-level-order-traversal</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/">https://oj.leetcode.com/problems/binary-tree-level-order-traversal/</a></p>

<!-- more -->


<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    if (root == null) return new ArrayList&lt;List&lt;Integer&gt;&gt;();

    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;();

    row.add(root.val);
    result.add(row);

    row = new ArrayList&lt;Integer&gt;();

    List&lt;List&lt;Integer&gt;&gt; leftList = null;
    if (root.left != null) {
        row.add(root.left.val);
        leftList = levelOrder(root.left);
    }

    List&lt;List&lt;Integer&gt;&gt; rightList = null;
    if (root.right != null) {
        row.add(root.right.val);
        rightList = levelOrder(root.right);
    }

    if (row.size() &gt; 0) {
        result.add(row);
    }

    if (leftList != null) {
        leftList = leftList.subList(1, leftList.size());
    }

    if (rightList != null) {
        rightList = rightList.subList(1, rightList.size());
    }

    int i = 0;
    int leftSize = leftList != null ? leftList.size() : 0;
    int rightSize = rightList != null ? rightList.size() : 0;

    for (; i &lt; leftSize; i++) {
        row = new ArrayList&lt;Integer&gt;();

        row.addAll(leftList.get(i));
        if (i &lt; rightSize) row.addAll(rightList.get(i)); 

        result.add(row);
    }
    for (; i &lt; rightSize; i++) {
        row = new ArrayList&lt;Integer&gt;();

        row.addAll(rightList.get(i));

        result.add(row);
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
