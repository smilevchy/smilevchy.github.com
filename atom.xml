<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2015-10-05T23:03:22+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Something About Inflation]]></title>
    <link href="http://smilevchy.github.io/blog/2015/10/05/something-about-inflation/"/>
    <updated>2015-10-05T22:41:19+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/10/05/something-about-inflation</id>
    <content type="html"><![CDATA[<p>When using view inflation, there are something we should know.</p>

<!-- more -->


<h1>How to inflate a view? Usually by calling&hellip;</h1>

<ul>
<li>View#inflate(Context context, int resource, ViewGroup root)</li>
<li>LayoutInflater#inflate(int resource, ViewGroup root)</li>
<li>LayoutInflater#inflate(int resource, ViewGroup root, boolean attachToRoot)</li>
</ul>


<p>Calling is simple. The problem is <em>which one should you call and what arguments should you pass</em>.</p>

<p>To solve these questions, the key is to <em>take insight in the method signature and dive into the source code</em>.</p>

<p>Taking a brief example here:</p>

<pre><code>// A view which presents container
ViewGroup parent = (ViewGroup) findViewById(R.id.container);

// result: layout_height = wrap_content, layout_width = match_parent
view = LayoutInflater.from(this).inflate(R.layout.item, null);
parent.addView(view);

// result: layout_height = 100, layout_width = 100
view = LayoutInflater.from(this).inflate(R.layout.item, null);
parent.addView(view, 100, 100);

// result: layout_height = 25dp, layout_width = 25dp
// returned view is the root view of R.layout.item due to attachRoot = false
view = LayoutInflater.from(this).inflate(R.layout.item, parent, false);
parent.addView(view);

// result: layout_height = 25dp, layout_width = 25dp 
// parent.addView is not necessary as this is already done by attachRoot = true
// returned view is parent due to parent supplied as hierarchy root and attachRoot = true
view = LayoutInflater.from(this).inflate(R.layout.red, parent, true);
</code></pre>

<p>Above code explains the results of different methods.</p>

<p><a href="https://possiblemobile.com/2013/05/layout-inflation-as-intended/">Here is another useful resources</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/19/best-time-to-buy-and-sell-stock/"/>
    <updated>2015-01-19T14:12:40+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/19/best-time-to-buy-and-sell-stock</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/">https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>

<!-- more -->


<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;

    int local = 0;
    int global = 0;
    for (int i = 1, len = prices.length; i &lt; len; i++) {
        local = Math.max(local + prices[i] - prices[i - 1], 0);
        global = Math.max(local, global);
    }

    return global;
}

// brute force (time limit exceed)
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;

    int maxProfit = 0;
    int localProfit = 0;
    for (int i = 0, len = prices.length; i &lt; len - 1; i++) {
        int max = 0;
        for (int j = i + 1; j &lt; len; j++) {
            if (prices[j] &gt; max) max = prices[j];
        }

        localProfit = max - prices[i];
        if (localProfit &gt; maxProfit) maxProfit = localProfit;
    }

    return maxProfit;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intersection of Two Linked Lists]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/19/intersection-of-two-linked-lists/"/>
    <updated>2015-01-19T10:36:39+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/19/intersection-of-two-linked-lists</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/intersection-of-two-linked-lists/">https://oj.leetcode.com/problems/intersection-of-two-linked-lists/</a></p>

<!-- more -->


<pre><code>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) return null;
    if (headA == headB) return headA;

    ListNode cursorA = headA;
    ListNode cursorB = headB;
    while (cursorA != null &amp;&amp; cursorB != null) {
        cursorA = cursorA.next;
        cursorB = cursorB.next;
    }

    ListNode longCursorStart = null;
    ListNode longCursorEnd = null;
    ListNode shortCursor = null;
    if (cursorA != null) {
        longCursorStart = headA;
        longCursorEnd = cursorA;
        shortCursor = headB;
    } else if (cursorB != null) {
        longCursorStart = headB;
        longCursorEnd = cursorB;
        shortCursor = headA;
    } else {
        longCursorStart = headA;
        longCursorEnd = null;
        shortCursor = headB;
    }

    while (longCursorStart != null &amp;&amp; longCursorEnd != null) {
        longCursorStart = longCursorStart.next;
        longCursorEnd = longCursorEnd.next;
    }

    while (longCursorStart != shortCursor) {
        longCursorStart = longCursorStart.next;
        shortCursor = shortCursor.next;
    }

    return longCursorStart;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Gas Station]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/16/leetcode-gas-station/"/>
    <updated>2015-01-16T18:05:34+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/16/leetcode-gas-station</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/gas-station/">https://oj.leetcode.com/problems/gas-station/</a></p>

<!-- more -->


<pre><code>public int canCompleteCircuit(int[] gas, int[] cost) {
    if (gas == null || cost == null || gas.length != cost.length) {
        return -1;
    }

    int totalGas = 0;
    int subSeqGas = 0;
    int start = 0;
    for (int i = 0, numGasStation = gas.length; i &lt; numGasStation; i++) {
        subSeqGas += gas[i] - cost[i];
        totalGas += gas[i] - cost[i];

        if (subSeqGas &lt; 0) {
            subSeqGas = 0;
            start = i + 1;
        }
    }

    return totalGas &gt;= 0 ? start : -1;
}

public int canCompleteCircuit(int[] gas, int[] cost) {
    // brute force (will meet time limit exceed)

    if (gas == null || cost == null || gas.length != cost.length) return -1;

    int numGasStation = gas.length;
    int remainGas = 0;
    int start = 0;
    boolean found = false;

    while (!found &amp;&amp; start &lt; numGasStation) {
        remainGas = 0;

        for (int index = start;;) {
            remainGas += gas[index];

            if (remainGas &gt;= cost[index]) {
                remainGas -= cost[index];

                if (index == numGasStation - 1) {
                    index = 0;
                } else {
                    index++;
                }

                if (index == start) {
                    found = true;
                    break;
                }
            } else {
                start++;
                break;
            }
        }

    }

    return found ? start : -1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Implement strStr()]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-implement-strstr/"/>
    <updated>2015-01-15T15:06:59+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-implement-strstr</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/implement-strstr/">https://oj.leetcode.com/problems/implement-strstr/</a></p>

<!-- more -->


<pre><code>public int strStr(String haystack, String needle) {
    if (haystack == null || needle == null) return -1;

    int haystackLen = haystack.length();
    int needleLen = needle.length();

    if (needleLen &gt; haystackLen) return -1;
    if (needleLen == 0) return 0;

    char[] haystackChars = haystack.toCharArray();
    char[] needleChars = needle.toCharArray();

    int index = 0;
    boolean found = false;
    while (index &lt; haystackLen) {
        if (haystackLen - index &lt; needleLen) {
            break;
        }

        int i = index;

        for (int j = 0; j &lt; needleLen; j++) {
            if (needleChars[j] != haystackChars[i]) {
                break;
            }

            i++;

            if (j == needleLen - 1) {
                found = true;
            }
        }

        if (found) {
            break;
        } else {
            index++;
        }
    }

    return found ? index : -1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Majority Element]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-majority-element/"/>
    <updated>2015-01-15T11:33:16+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-majority-element</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/majority-element/">https://oj.leetcode.com/problems/majority-element/</a></p>

<!-- more -->


<pre><code>public int majorityElement(int[] num) {
    Map&lt;Integer, Integer&gt; numToCount = new HashMap&lt;Integer, Integer&gt;();

    for (int i = 0, len = num.length; i &lt; len; i++) {
        if (numToCount.get(num[i]) != null) {
            numToCount.put(num[i], numToCount.get(num[i]) + 1);
        } else {
            numToCount.put(num[i], 1);
        }
    }

    int majorityNum = 0;
    int maxLen = Integer.MIN_VALUE;

    Iterator&lt;Integer&gt; itr = numToCount.keySet().iterator();

    while (itr.hasNext()) {
        int key = itr.next();
        if (numToCount.get(key) &gt; maxLen) {
            maxLen = numToCount.get(key);
            majorityNum = key;
        }
    }

    return majorityNum;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Min Stack]]></title>
    <link href="http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack/"/>
    <updated>2015-01-15T10:04:07+08:00</updated>
    <id>http://smilevchy.github.io/blog/2015/01/15/leetcode-min-stack</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/min-stack/">https://oj.leetcode.com/problems/min-stack/</a></p>

<!-- more -->


<pre><code>class MinStack {
    private List&lt;Integer&gt; normalStack = new ArrayList&lt;Integer&gt;();
    private List&lt;Integer&gt; minNumStack = new ArrayList&lt;Integer&gt;();


    public void push(int x) {
        normalStack.add(x);

        if (minNumStack.isEmpty() || minNumStack.get(minNumStack.size() - 1) &gt;= x) {
            minNumStack.add(x);
        }
    }

    public void pop() {
        if (normalStack.isEmpty()) return;

        int x = normalStack.get(normalStack.size() - 1);
        normalStack.remove(normalStack.size() - 1);

        if (!minNumStack.isEmpty() &amp;&amp; x == minNumStack.get(minNumStack.size() - 1)) {
            minNumStack.remove(minNumStack.size() - 1);
        }
    }

    public int top() {
        if (normalStack.isEmpty()) return 0;

        return normalStack.get(normalStack.size() - 1);
    }

    public int getMin() {
        if (minNumStack.isEmpty()) return 0;

        return minNumStack.get(minNumStack.size() - 1);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Something About Installing Genymotion]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/28/something-about-installing-genymotion/"/>
    <updated>2014-12-28T16:21:48+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/28/something-about-installing-genymotion</id>
    <content type="html"><![CDATA[<p>趁着有时间安装了 Genymotion，它需要依据 Oracle 的 VirtualBox 来工作，所以就是说你还需要安装 Oracle VM VirtualBox 这个软件。</p>

<p>一般设计上来说，Genymotion 应该要提供一个位置来设置指向 VirtualBox 软件路径的，可是找了它的安装目录、软件界面设置都没有发现这个位置，所以就是说，它可能是固定指向 VirtualBox 的。</p>

<p>即，需要按照它给定的固定路径来安装 VirtualBox ，不然就无法启动成功。至于那个固定路径是什么，可以去它的日志文件里查找，如果没什么改变的话，位置一般是在用户数据文件夹里，名字为 genymotion.log。通过查看它的错误日志，找到指向 VirtualBox 时发生错误的日志记录，那里就有写该固定路径。</p>

<p>这是我自己遇到的错误，因为在安装 Genymotion 前我就一直使用 VirtualBox ，而且是自定义路径。 &ndash;_-所以需要卸载重装，安装它的固定路径。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reaction to Effective Java]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/15/reaction-to-effective-java/"/>
    <updated>2014-12-15T23:26:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/15/reaction-to-effective-java</id>
    <content type="html"><![CDATA[<p><strong>第一遍</strong></p>

<ul>
<li>单元素的枚举类型已经成为实现 Singleton 的最佳方法</li>
<li>清空对象引用应该是一种例外，而不是一种规范行为</li>
<li>内存泄漏原因：

<ul>
<li>一般而言，只要类是自己管理内存，程序员就应该警惕内存泄漏问题</li>
<li>缓存</li>
<li>监听器和其他回调</li>
</ul>
</li>
<li>内存泄漏解决方案：

<ul>
<li>通常不会有明显表现，可能持续很长时间。只能通过仔细检查代码或者利用 Heap Profiler 才能发现</li>
</ul>
</li>
<li>尽量用静态工厂方法替代构造器</li>
<li>当想使用 B 扩展(继承) A 时，问自己两个问题：

<ul>
<li>每个 B 确实是 A 吗</li>
<li>若 A 的 API 有缺陷，是否允许将其缺陷传播到 B 中</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interrogation of AsyncTask]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/11/interrogation-of-asynctask/"/>
    <updated>2014-12-11T20:48:12+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/11/interrogation-of-asynctask</id>
    <content type="html"><![CDATA[<p>当需要进行一项耗时久的任务时（下载文件、访问网络等），一般都知道必须在 worker thread 中进行。但是在现实场景中不可能单纯新建一个线程那么简单，大部分时候需要和 main thread 进行交互、或者说还要保证任务能够成功进行，不会遇到被销毁的情况。可是，单纯的 thread 并不具备这些能力。</p>

<p>那怎么办呢？</p>

<!-- more -->


<p>以上说的场景交互在 Android 开发中形成了一种 pattern，而 Android 团队就把这种 pattern 提取成了一个工具类出来给开发者使用，即 AsyncTask。</p>

<p>关于 AsyncTask 的使用方法可参见<a href="http://developer.android.com/reference/android/os/AsyncTask.html">官方文档</a>。</p>

<p>一般情况下，AsyncTask 的确就是那么容易使用。但在某些情况下，你会发现这个类出问题了。</p>

<p>这个是因为 AsyncTask 的本质缺陷导致。</p>

<p>Android 的基本组件 Activity/Receiver/Service 本身具有一定的生命周期管理（Life Circle Management），而 AsyncTask 并不具备与之对应的生命周期管理。</p>

<p>假设一个场景如下，你编写了一个 AsyncTask，然后在一个 Activity 里调用该 AsyncTask，并且把自身引用传递进去，为了后续的一些函数调用。大部分情况下是没有问题，但是当设备转换屏幕方向时，Android 系统会销毁这个 Activity 再重建一个新的，此时之前传进去 AsyncTask 里的引用已经“无效”了，因为它指向了一个被销毁的 Activity，你再也不可能对其做任何 UI 操作，甚至会抛出 NullPointerException。即是说，你需要注意传进给 AsyncTask 的任何具有生命周期管理的引用，下一秒这个引用可能就失效了。</p>

<p>解决方法？</p>

<p>对于此类具有生命周期管理的引用统一使用 WeakReference，当引用指向的对象被系统销毁时，可以让这些对象被 GC 处理，同时在使用到引用的代码处再判断是否非空来决定怎么处理。</p>

<p>此外，当外部发生生命周期状态改变时（按返回键、Home键、取消进度框等），若对应的 AsyncTask 需要做相应的反应时（取消任务进行、继续任务进行等），还需要监听外部的生命周期状态改变事件。</p>

<p>总之，AsyncTask 看起来很简单，但需要在实际场景中考虑是否可能会出现问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Call Function Lazily]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/10/call-function-lazily/"/>
    <updated>2014-12-10T10:19:10+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/10/call-function-lazily</id>
    <content type="html"><![CDATA[<p>某些场景下，在某些模块还未初始化完毕时就调用该模块的函数，可能会导致错误。这时候就需要延迟调用函数，等待该模块初始化完毕先再调用。</p>

<!-- more -->


<p>*. setTimeout 方法</p>

<pre><code>ready = false;

this.func_to_be_called = function(params) {
    if (!ready) {
        setTimeout(function() {
            func_to_be_called(params);
        }, 100);
    }
};

var init = function() {
    // XXX

    ready = true;
};
</code></pre>

<p>*. 缓存调用函数对象方法</p>

<pre><code>var ready = false;
var waitings = [];
var addWaiting = function (fn, param, cb) {
    waitings.push({
        fn: fn,
        param: param,
        cb: cb
    });
};
var noticeWaiting = function () {
    $.each(waitings, function (index, waiting) {
        waiting.fn(waiting.param, waiting.cb);
    });
    waitings = [];
};

this.func_to_be_called = function(params) {
    if (!ready) {
        addWaiting(function (params) {
            _this.func_to_be_called(params);
        }, params, null);
        return;
    }
};

var init = function() {
    // XXX

    ready = true;
    noticeWaiting();
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Game - CatRush]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/08/my-first-game-catrush/"/>
    <updated>2014-12-08T22:15:23+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/08/my-first-game-catrush</id>
    <content type="html"><![CDATA[<p>完成了第一个移动端游戏，其为 CatRush。</p>

<!-- more -->


<hr />

<p>展示如下所示(当当当~当):</p>

<p>首先是图标:</p>

<p><img src="http://smilevchy.github.io/images/artifacts/catrush/icon.png" alt="图标" /></p>

<p>接下来是 &ldquo;启动画面&rdquo; (专业术语为 SplashScreen):</p>

<p><img src="http://smilevchy.github.io/images/artifacts/catrush/splash_scene_1.png" alt="启动画面1" />
<img src="http://smilevchy.github.io/images/artifacts/catrush/splash_scene_2.png" alt="启动画面2" />
<img src="http://smilevchy.github.io/images/artifacts/catrush/splash_scene_3.png" alt="启动画面3" /></p>

<p>启动画面是一项很重要的元素。它可以做为一个公司或者个人的标识。通过持久的运营，让它变成一个品牌。让大家一看到这个标识就知道是哪个公司或者个人的作品。比如说漫威电影的开头都会有一段短动画，或者美国好莱坞的某个电影公司开头都会有一段闪电打雷开车在高速路上的动画。</p>

<p>启动画面后是 &ldquo;主菜单&rdquo; 画面:
<img src="http://smilevchy.github.io/images/artifacts/catrush/main_menu_scene.png" alt="主菜单" /></p>

<p>&ldquo;关于&rdquo; 界面:
<img src="http://smilevchy.github.io/images/artifacts/catrush/about_scene.png" alt="关于界面" /></p>

<p>&ldquo;选项&rdquo; 界面:
<img src="http://smilevchy.github.io/images/artifacts/catrush/option_scene.png" alt="选项界面" /></p>

<p>&ldquo;分数记录&rdquo; 界面:
<img src="http://smilevchy.github.io/images/artifacts/catrush/score_scene.png" alt="分数记录界面" />
这里触摸右下的小黑猫可以截屏分享当前最高分数至社交软件。</p>

<p>最后是 &ldquo;游戏界面&rdquo;
<img src="http://smilevchy.github.io/images/artifacts/catrush/game_scene.png" alt="游戏界面" />
右边两只小黑爪一只是加速，一只是减速。</p>

<p>没错，你要做的就是控制小黑猫的速度，躲避天上掉下来的毛线团和秋刀鱼。</p>

<p>游戏中的音乐/音效资源均是采用别人的(不进行商业化就不会侵权了吧)，有<a href="http://zh.wikipedia.org/zh/%E5%B9%BB%E5%8C%96%E6%88%90%E9%A3%8E">幻化成风</a> 和<a href="http://zh.wikipedia.org/zh/%E5%8B%87%E6%B0%A3100%25">勇气100%</a>。</p>

<p>图片资源大部分是上网找的，有些是自己画的(没错，看起来是幼稚园水平的就是本人画的)。</p>

<hr />

<p>smilevchy: 关于本游戏正式介绍完毕。</p>

<p>猫老师: 喂!貌似你介绍的很简短啊!</p>

<p>smilevchy: Haha&hellip;&hellip;本人是一名程序员啊，对于游戏策划、数值设计、图片制作、音效/音乐制作目前还都是 HelloWorld 水平啊，请老师再给我点时间，让我好好历练一下吧。</p>

<p>猫老师: Soga！少年，请继续努力吧！</p>

<p>smilevchy: 好的! 猫老师。</p>

<p>猫老师: 对了，最后再问个问题。为什么猫要躲避毛线团和秋刀鱼啊，混蛋，吾等猫君可是很喜欢毛线团和秋刀鱼的喵。</p>

<p>smilevchy: 嘿嘿嘿，猫老师，这又是另一个故事了&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Minimum Path Sum]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum/"/>
    <updated>2014-12-08T11:08:51+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/08/leetcode-minimum-path-sum</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/minimum-path-sum/">https://oj.leetcode.com/problems/minimum-path-sum/</a></p>

<!-- more -->


<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null || grid.length == 0) return 0;

    int rows = grid.length;
    int cols = grid[0].length;
    int[] res = new int[cols];
    res[0] = grid[0][0];

    for (int i = 1; i &lt; cols; i++) {
        res[i] = res[i - 1] + grid[0][i];
    }

    for (int i = 1; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            int top = res[j];
            int left = j == 0 ? Integer.MAX_VALUE : res[j - 1];
            res[j] = Math.min(top, left) + grid[i][j];
        }
    }

    return res[cols - 1];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Convert Sorted Array to Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree/"/>
    <updated>2014-12-05T10:56:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/05/leetcode-convert-sorted-array-to-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num == null || num.length == 0) return null;

    List&lt;Integer&gt; cursor = new ArrayList&lt;Integer&gt;(1);
    cursor.add(0);

    return sortedArrayToBSTHelper(num, 0, num.length - 1, cursor);
}

public TreeNode sortedArrayToBSTHelper(int[] num, int low, int high, List&lt;Integer&gt; cursor) {
    if (low &gt; high) return null;

    int mid = (low + high) / 2;

    TreeNode left = sortedArrayToBSTHelper(num, low, mid - 1, cursor);

    TreeNode root = new TreeNode(num[cursor.get(0)]);
    root.left = left;

    cursor.set(0, cursor.get(0) + 1);

    TreeNode right = sortedArrayToBSTHelper(num, mid + 1, high, cursor);
    root.right = right;

    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-find-minimum-in-rotated-sorted-array/"/>
    <updated>2014-12-04T14:33:54+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-find-minimum-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/">https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p>

<!-- more -->


<pre><code>public int findMin(int[] num) {
    if (num == null || num.length == 0) return 0;

    return findMinHelper(num, 0, num.length - 1);
}

public int findMinHelper(int[] num, int low, int high) {
    if (low &gt; high) return 0;

    if (high - low &lt;= 1) return Math.min(num[low], num[high]);

    int mid = (low + high) / 2;
    int result = Math.min(num[mid], Math.min(findMinHelper(num, low, mid - 1), findMinHelper(num, mid + 1, high)));

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Set Matrix Zeroes]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes/"/>
    <updated>2014-12-04T12:03:59+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-set-matrix-zeroes</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/set-matrix-zeroes/">https://oj.leetcode.com/problems/set-matrix-zeroes/</a></p>

<!-- more -->


<pre><code>public void setZeroes(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean[] row = new boolean[m];
    boolean[] col = new boolean[n];

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                row[i] = true;
                col[j] = true;
            }
        }
    }

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (row[i] || col[j]) {
                matrix[i][j] = 0;                   
            }
        }
    }
}

public void setZeroesV2(int[][] matrix) {
    if (matrix == null) return;

    int m = matrix.length;
    int n = matrix[0].length;

    boolean firstRowZero = false;
    boolean firstColZero = false;

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;

                if (i == 0) firstRowZero = true;
                if (j == 0) firstColZero = true;
            }
        }
    }

    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            if (matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j] = 0;
        }
    }

    if (firstRowZero) {
        for (int i = 0; i &lt; n; i++) matrix[0][i] = 0;
    }

    if (firstColZero) {
        for (int i = 0; i &lt; m; i++) matrix[i][0] = 0;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Validate Binary Search Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/04/leetcode-validate-binary-search-tree/"/>
    <updated>2014-12-04T11:04:02+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/04/leetcode-validate-binary-search-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/validate-binary-search-tree/">https://oj.leetcode.com/problems/validate-binary-search-tree/</a></p>

<!-- more -->


<pre><code>public boolean isValidBST(TreeNode root) {
    if (root == null) return true;

    LinkedList&lt;TreeNode&gt; inorderNodes = new LinkedList&lt;TreeNode&gt;();
    List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;();

    while (root != null || !inorderNodes.isEmpty()) {
        if (root != null) {
            inorderNodes.push(root);
            root = root.left;
        } else {
            TreeNode top = inorderNodes.pop(); 
            vals.add(top.val);
            root = top.right;
        }
    }

    for (int i = 1, s = vals.size(); i &lt; s; i++) {
        if (vals.get(i) &lt;= vals.get(i -1)) return false;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Permutations]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations/"/>
    <updated>2014-12-03T10:48:28+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/03/leetcode-permutations</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/permutations/">https://oj.leetcode.com/problems/permutations/</a></p>

<!-- more -->


<p></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    if (num == null || num.length == 0) return result;

    List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;();
    for (int e : num) {
        first.add(e);
    }
    result.add(first);

    for (int pos = 0, len = num.length; pos &lt; len; pos++) {
        for (int i = 0, s = result.size(); i &lt; s; i++) {
            for (int j = pos + 1; j &lt; len; j++) {
                List&lt;Integer&gt; ele = new ArrayList&lt;Integer&gt;(result.get(i));                  

                ele.set(j, ele.get(j) ^ ele.get(pos));
                ele.set(pos, ele.get(j) ^ ele.get(pos));
                ele.set(j, ele.get(j) ^ ele.get(pos));

                result.add(ele);
            }
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Rotate Image]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image/"/>
    <updated>2014-12-02T15:04:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-rotate-image</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/rotate-image/">https://oj.leetcode.com/problems/rotate-image/</a></p>

<!-- more -->


<pre><code>/*
 * [1, 1, 1, 1, 1]
 * [1, 2, 2, 2, 1]
 * [1, 2, 3, 2, 1]
 * [1, 2, 2, 2, 1]
 * [1, 1, 1, 1, 1]
 * 
 * Like shown above, take the 2-dim array as it has some layers wrapping each other, layer 1 wraps layer 2, layer 2 wraps layer 3......
 * For each layer, we can divide it into four blocks : top row, right col, bottom row, left col.
 * What we have to do is : move top row to right col, right col to bottom row, bottom row to left col, left col to top row.
 * And, we do this for times of numbers of layers(matrix's length / 2).  
 */
public void rotate(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;

    int matrixSize = matrix.length;
    int layerNum = matrixSize / 2;

    for (int i = 0; i &lt; layerNum; i++) {
        for (int low = i, high = matrixSize - i - 1; low &lt; high; low++) {
            int temp = matrix[i][low];

            // move left col to top row
            matrix[i][low] = matrix[matrixSize - low - 1][i];

            // move bottom row to left col
            matrix[matrixSize - low - 1][i] = matrix[high][matrixSize - low - 1];

            // move right col to bottom row
            matrix[high][matrixSize - low - 1] = matrix[low][high];

            // move top row to right col
            matrix[low][high] = temp; 
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Evaluate Reverse Polish Notation]]></title>
    <link href="http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation/"/>
    <updated>2014-12-02T11:05:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/12/02/leetcode-evaluate-reverse-polish-notation</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>

<!-- more -->


<pre><code>public int evalRPN(String[] tokens) {
    if (tokens == null || tokens.length == 0) return 0;

    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
    int result = 0;
    String ele = null;

    for (int i = 0, len = tokens.length; i &lt; len; i++) {
        ele = tokens[i];

        if ("+".equals(ele) || "-".equals(ele) || "*".equals(ele) || "/".equals(ele)) {
            if (stack.isEmpty()) return result;
            Integer right = stack.pop();

            if (stack.isEmpty()) return result;
            Integer left = stack.pop();

            if ("+".equals(ele)) {
                stack.push(left + right);                   
            } else if ("-".equals(ele)) {
                stack.push(left - right);
            } else if ("*".equals(ele)) {
                stack.push(left * right);
            } else if ("/".equals(ele)) {
                stack.push(left / right);
            }
        } else {
            stack.push(Integer.valueOf(ele));
        }
    }

    if (!stack.isEmpty()) result = Integer.valueOf(stack.pop());

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
