<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-07T16:29:46+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Palindrome]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome/"/>
    <updated>2014-11-07T16:28:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/valid-palindrome/">https://oj.leetcode.com/problems/valid-palindrome/</a></p>

<pre><code>public boolean isPalindrome(String s) {
    if (s == null) return false;

    s = s.trim();

    if (s.equals("")) return true;

    int i = 0;
    int j = s.length() - 1;
    char leftChar;
    char rightChar;

    while (i &lt; j) {
        leftChar = s.charAt(i);

        if ((leftChar &lt; 'a' || leftChar &gt; 'z') &amp;&amp; (leftChar &lt; 'A' || leftChar &gt; 'Z') &amp;&amp; (leftChar &lt; '0' || leftChar &gt; '9')) {
            i++;
            continue;
        }

        rightChar = s.charAt(j);

        if ((rightChar &lt; 'a' || rightChar &gt; 'z') &amp;&amp; (rightChar &lt; 'A' || rightChar &gt; 'Z') &amp;&amp; (rightChar &lt; '0' || rightChar &gt; '9')) {
            j--;
            continue;
        }

        if (leftChar &gt; rightChar) {
            if (leftChar - 32 != rightChar) return false;
        } else if (leftChar &lt; rightChar) {
            if (leftChar + 32 != rightChar) return false;
        }

        i++;
        j--;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Count and Say]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say/"/>
    <updated>2014-11-07T15:53:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/count-and-say/">https://oj.leetcode.com/problems/count-and-say/</a></p>

<pre><code>public String countAndSay(int n) {
    if (n &lt; 0) return "";

    StringBuilder sb = new StringBuilder();

    if (n == 1) {
        return sb.append("1").toString();
    }

    String prevStr = countAndSay(n - 1);
    int length = prevStr.length();
    char prevChar = ' '; 
    int accumulator = 0;

    for (int i = 0; i &lt; length; i++) {
        char c = prevStr.charAt(i);

        if (c == prevChar) {
            accumulator++;
        } else {
            if (prevChar == ' ') {
                prevChar = c;
                accumulator = 1;
                continue;
            }

            sb.append("" + accumulator + prevChar);

            prevChar = c;
            accumulator = 1;
        }
    }

    if (accumulator &gt; 0) sb.append("" + accumulator + prevChar);

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Palindrome Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number/"/>
    <updated>2014-11-06T15:59:14+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/palindrome-number/">https://oj.leetcode.com/problems/palindrome-number/</a></p>

<pre><code>public boolean isPalindrome(int x) {
    if (x &lt; 0) return false;

    // get length of digit
    int carryLength = 1;
    while (x / carryLength &gt;= 10) {
        carryLength *= 10;
    }

    while (x &gt; 0) {
        // test if the first and the end digit is equal; if not, return false
        if (x / carryLength != x % 10) return false;

        x = x % carryLength / 10;    // get the new number without the first and the end digit
        carryLength /= 100;    // for cutting the first and the end digit, we need to shrink carry length by 2 times
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number/"/>
    <updated>2014-11-05T18:29:57+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number</id>
    <content type="html"><![CDATA[<p>原题链接：<a href="https://oj.leetcode.com/problems/valid-number/">https://oj.leetcode.com/problems/valid-number/</a></p>

<p>这道题主要是注意 &ldquo;+&rdquo;/&ldquo;&ndash;&rdquo;/&ldquo;e&rdquo;/&ldquo;E&rdquo;/&ldquo;.&rdquo; 的位置，遍历字符串，当遇到上述几种符号时就判断位置是否正确，不正确则退出遍历过程，正确则继续，遇到非数字则退出遍历过程。</p>

<pre><code>public boolean isNumber(String s) {
    if (s == null) {
        return false;
    }

    String str = s.trim();

    if (str.length() == 0) {
        return false;
    }

    boolean result = true;
    int length = str.length();
    char c;
    boolean exponentialExisted = false;
    boolean dotExisted = false;
    boolean quitLoop = false;
    boolean digitExisted = false;

    for (int i = 0; i &lt; length; i++) {
        c = str.charAt(i);

        if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
            digitExisted = true;
        } else {
            switch (c) {
                case '+':
                case '-':
                    if (i == length - 1 || i != 0 &amp;&amp; str.charAt(i - 1) != 'e' &amp;&amp; str.charAt(i - 1) != 'E') {
                        result = false;

                        quitLoop = true;
                    }

                    break;

                case 'e':
                case 'E':
                    if (exponentialExisted || i == 0 || i == length - 1 || ((str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9') &amp;&amp; str.charAt(i - 1) != '.') || !digitExisted) {
                        result = false;

                        quitLoop = true;
                    }

                    exponentialExisted = true;

                    break;

                case '.':
                    if (dotExisted || exponentialExisted || length == 1 || (i == length - 1 &amp;&amp; (str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9')) || 
                        (i == 0 &amp;&amp; ((str.charAt(i + 1) &lt; '0' || str.charAt(i + 1) &gt; '9') &amp;&amp; (str.charAt(i + 1) != 'e' &amp;&amp; str.charAt(i + 1) != 'E')))) {
                        result =  false;

                        quitLoop = true;
                    }

                    dotExisted = true;

                    break;

                default:
                    result = false;
                    quitLoop = true;
            }
        }

        if (quitLoop) break;
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Jump Game]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-jump-game/"/>
    <updated>2014-11-04T21:34:32+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-jump-game</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/jump-game/">https://oj.leetcode.com/problems/jump-game/</a></p>

<p>~_~ 这道题是看别人的解法的（当然，我不是照抄那种，看过理解了自己再写的）</p>

<pre><code>public boolean canJump(int[] A) {
    if (A == null || A.length == 0) {
        return false;
    }

    int size = A.length;
    int dstPosition = size - 1;
    int maxReachPosition = 0;

    for (int i = 0; i &lt;= maxReachPosition &amp;&amp; i &lt; size; i++) {
        maxReachPosition = Math.max(i + A[i], maxReachPosition);
    }

    if (maxReachPosition &lt; dstPosition) {
        return false;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Rotate List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-rotate-list/"/>
    <updated>2014-11-04T21:32:39+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-rotate-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/rotate-list/">https://oj.leetcode.com/problems/rotate-list/</a></p>

<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return head;
    }

    ListNode cursor = head;

    int length = 0;
    while (cursor != null) {
        cursor = cursor.next;
        length++;
    }

    if (n % length == 0) {
        return head;
    }

    int targetIndex = length - n % length;

    int currentIndex = 0;
    cursor = head;
    ListNode prev = null;

    while (currentIndex &lt; targetIndex) {
        prev = cursor;
        cursor = cursor.next;
        currentIndex++;
    }

    ListNode cursorTail = cursor;
    while (cursorTail.next != null) {
        cursorTail = cursorTail.next;
    }

    prev.next = null;
    cursorTail.next = head;
    head = cursor;

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Reverse Words in a String]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-words-in-a-string/"/>
    <updated>2014-11-04T21:30:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-words-in-a-string</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">https://oj.leetcode.com/problems/reverse-words-in-a-string/</a></p>

<pre><code>public String reverseWords(String s) {
    String[] words = s.trim().split("\\s+");
    StringBuilder sb = new StringBuilder("");

    for (int i = words.length - 1; i &gt;= 0; i--) {
        sb.append(words[i]);

        if (i &gt;= 1) {
            sb.append(" ");
        }
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Reorder List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-reorder-list/"/>
    <updated>2014-11-04T21:23:58+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-reorder-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/reorder-list/">https://oj.leetcode.com/problems/reorder-list/</a></p>

<p>正是这道题，让我知道了有 “快慢指针” 这种好东西。以前每当要做类似遍历链表的操作时，比如取中点，总是先遍历完一遍链表来获得长度，求得中点再遍历一次，实在是不雅观。而通过 “快慢指针”，只要写一次遍历就可以拿到中点。</p>

<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor != null &amp;&amp; quickCursor.next != null &amp;&amp; quickCursor.next.next != null &amp;&amp; slowCursor != null &amp;&amp; slowCursor.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;
    }

    ListNode head1 = head;
    ListNode head2 = slowCursor.next;

    head2 = reverseList(head2);

    while (head1 != null &amp;&amp; head2 != null) {
        ListNode head2Next = head2.next;
        head2.next = head1.next;
        head1.next = head2;
        head1 = head2.next;
        head2 = head2Next;

        if (head2 == null) {
            head1.next = null;
        }
    }
}

public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode cursor = head;
    ListNode next = null;

    while (cursor != null) {
        next = cursor.next;
        cursor.next = prev;
        prev = cursor;
        cursor = next;
    }

    return prev;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Add Two Numbers]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-add-two-numbers/"/>
    <updated>2014-11-04T21:21:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-add-two-numbers</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/add-two-numbers/">https://oj.leetcode.com/problems/add-two-numbers/</a></p>

<pre><code>public ListNode addTwoNumbers(ListNode left, ListNode right) {
    if (left == null &amp;&amp; right == null) {
        return null;
    }

    ListNode result = new ListNode(0);
    ListNode cursor = result;
    int carry = 0;

    while (left != null || right != null) {
        int val = 0;

        if (left != null) {
            val += left.val;
            left = left.next;
        }

        if (right != null) {
            val += right.val;
            right = right.next;
        }

        val += carry;
        int digit = val % 10;
        carry = val / 10;

        cursor.val = digit;

        if (left != null || right != null) {
            cursor.next = new ListNode(0);
            cursor = cursor.next;               
        }
    }

    if (carry &gt; 0) {
        cursor.next = new ListNode(1);
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Plus One]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-plus-one/"/>
    <updated>2014-11-04T21:19:18+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-plus-one</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/plus-one/">https://oj.leetcode.com/problems/plus-one/</a></p>

<pre><code>public byte[] plusOne(byte[] num) {
    if (num == null || num.length == 0) {
        return num;
    }

    byte[] result = num.clone();
    int length = num.length;

    for (int i = length - 1; i &gt;= 0; i--) {
        byte digit = result[i];
        result[i] = (byte) (digit + 1);

        if (result[i] &lt; 10) {
            break;
        } else {
            result[i] = 0;

            if (i == 0) {

                byte[] expandedNum = new byte[length + 1];
                expandedNum[0] = 1;

                return expandedNum;
            }
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Reverse Integer]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-integer/"/>
    <updated>2014-11-04T21:16:33+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-integer</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/reverse-integer/">https://oj.leetcode.com/problems/reverse-integer/</a></p>

<pre><code>public int reverse(int x) {
    String str = Integer.toString(x);
    StringBuilder sb = new StringBuilder(str.length());
    char c;

    if (str.indexOf('-') == 0) {
        sb.append('-');
    }
    for (int i = str.length() - 1; i &gt;= 0; i--) {
        c = str.charAt(i);

        if (c == '-') {
            break;
        }

        sb.append(c);
    }

    return Integer.parseInt(sb.toString());
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_String to Integer(atoi)]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-string-to-integer-atoi/"/>
    <updated>2014-11-04T21:10:18+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-string-to-integer-atoi</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/string-to-integer-atoi/">https://oj.leetcode.com/problems/string-to-integer-atoi/</a></p>

<p>这道题目着重点是 corner case 的处理，一串字符串在转换为整数时，需要考虑它的正负号，以及是否溢出。</p>

<pre><code>public int atoi(String str) {
    long resultNum = 0; 

    if (str == null || str.equals("")) {
        return (int) resultNum;
    } 

    str = str.trim();
    boolean negative = false;
    char c;

    for (int i = 0, length = str.length(); i &lt; length; i++) {
        c = str.charAt(i);

        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {
            if (c == '-') {
                negative = true;                
            }
        } else if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
            resultNum = resultNum * 10 + (c - '0');

            if (resultNum &gt; Integer.MAX_VALUE &amp;&amp; !negative) {
                resultNum = Integer.MAX_VALUE;
            } else if (negative &amp;&amp; resultNum * -1 &lt; Integer.MIN_VALUE) {
                resultNum = Integer.MIN_VALUE;
            }
        } else {
            break;
        }
    }

    return (int) (negative == true ? resultNum * -1 : resultNum);           
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Same Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-same-tree/"/>
    <updated>2014-11-04T21:08:15+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-same-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/same-tree/">https://oj.leetcode.com/problems/same-tree/</a></p>

<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null || p == q) {
        return true;
    } else if (p == null || q == null) {
        return false;
    }

    if (!isSameTree(p.left, q.left)) return false;
    if (!isSameTree(p.right, q.right)) return false;
    if (p.val == q.val) return true;

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Symmetric Tree]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-symmetric-tree/"/>
    <updated>2014-11-04T21:00:07+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-symmetric-tree</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/symmetric-tree/">https://oj.leetcode.com/problems/symmetric-tree/</a></p>

<p>一般涉及到树的问题我都喜欢用递归解法。</p>

<pre><code>public boolean isSymmetric(TreeNode root) {
    if (null == root) {
        return true;
    }

    if (root.left == null &amp;&amp; root.right == null) {
        return true;
    } 

    if (root.left == null || root.right == null) {
        return false;
    }

    TreeNode mirrorRootNodeOfLeft = new TreeNode(0);
    mirrorRootNodeOfLeft.left = root.left.left;
    mirrorRootNodeOfLeft.right = root.right.right;
    if (!isSymmetric(mirrorRootNodeOfLeft)) return false;

    TreeNode mirrorRootNodeOfRight = new TreeNode(0);
    mirrorRootNodeOfRight.left = root.left.right;
    mirrorRootNodeOfRight.right = root.right.left;
    if (!isSymmetric(mirrorRootNodeOfRight)) return false;

    if (root.left.val == root.right.val) return true; 

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Understanding]]></title>
    <link href="http://smilevchy.github.io/blog/2014/10/22/todays-understanding/"/>
    <updated>2014-10-22T15:37:26+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/10/22/todays-understanding</id>
    <content type="html"><![CDATA[<p>在设计模块接口时，入口参数绝对要设计成数值形式啊，之前居然设计成了字符串形式，由于有其他模块也调用到，现在造成的局面就是根本没有扩展性，而且要修改的话还要让其他调用模块也进行相应修改。</p>

<p>悲剧&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Understanding]]></title>
    <link href="http://smilevchy.github.io/blog/2014/10/21/todays-understanding/"/>
    <updated>2014-10-21T20:32:06+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/10/21/todays-understanding</id>
    <content type="html"><![CDATA[<p>今天重构几个月前的代码过程中，感觉到种种阻力。
原因在于代码的耦合度过高，信息过于具体、过于分散，导致修改一处代码时，常常要联动修改很多处地方。</p>

<p><strong>感悟一：代码还是抽象化程度高一点才好。</strong></p>

<p>现在写代码的感觉比以前好一点，以前只会堆砌功能，不懂得整体架构设计，写出来的代码可以说是存在于 ”开发时“。
现在开始有意识注意整体的设计，代码的可阅读性，力求让代码不仅存在于”开发时“，也存在于”阅读时“、”维护时“。</p>

<p><strong>感悟二：像写作文一样写代码，让非代码作者阅读时就像在读一篇文章一样，有整体架构，有段落意思，尽量让代码的内涵浮出海平面。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/10/19/todays-shock/"/>
    <updated>2014-10-19T22:12:30+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/10/19/todays-shock</id>
    <content type="html"><![CDATA[<p>在看《Ruby 编程语言》时，看到一个概念，叫做 Shebang 注释。
一开始以为是那本书籍打印出错了，因为 ”Shebang“ 看起来怎么也不像英文单词，而且直觉上能发成中文的音。
但是还是觉得不对，所以就搜索了一下。</p>

<p>&ndash;_&ndash; 结果显示，维基百科上真的有叫 Shebang 的条目。
看了条目内容，才知道原来 Shebang 指的就是平常 unix shell 文件开头第一行的那句话（#!/bin/sh）的前两个字符。
而一般把形如 #!XXXXX 的语句叫做 Shebang 注释。</p>

<p>我真是孤陋寡闻&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let Android Talk to Computer With Socket]]></title>
    <link href="http://smilevchy.github.io/blog/2014/09/16/let-android-talk-to-computer-with-socket/"/>
    <updated>2014-09-16T21:45:17+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/09/16/let-android-talk-to-computer-with-socket</id>
    <content type="html"><![CDATA[<p>在没有公网/wifi的情况下让 Android 手机通过 USB 或者让虚拟机里的 Android 系统与电脑进行通信。</p>

<!-- more -->


<p>基本原理是当 Android 手机通过 USB 连接电脑时，两者之间就形成了一个局域网（具体是由 ADB 实现的）。
嗯，看到这里只要了解网络编程的同学就知道怎么做了。
就是把 Android 手机作为服务器，监听某个端口来获取客户端连接,而 PC 可以作为客户端。
这里的问题是客户端要怎么连接到服务器的端口，这个需要运行 adb shell 指令 ：</p>

<pre><code>adb.exe forward tcp:[port1] tcp:[port2]  // port1: PC 上的端口; port2: Android 上的端口。此处会把 PC 上发往 port1 的信息转发至 Android 的 port2
</code></pre>

<p>Android 服务器代码：</p>

<pre><code>void startServer() {
    ServerSocket serverSocket = null;

    try {
        Log.e("Android", "start to accpet");

        serverSocket = new ServerSocket(SERVER_PORT); // 即 port2

        while (true) {
            Socket client = serverSocket.accept();

            Log.e("Android", "receive client");

            try {
                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
                final String str = in.readLine();

                Log.e("Android", str);

                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        show.setText(str);
                    }
                });

                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true);
                out.println("I'm Android");
                in.close();
                out.close();
            } catch (Exception e) {
                Log.e("Android", "");
                e.printStackTrace();
            } finally {
                client.close();
                Log.e("Android", "");
            }
            Thread.sleep(3000);
        }
    } catch (Exception e) {
        Log.e("Android", "");
        e.printStackTrace();
    } finally {
        if (serverSocket != null) {
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>

<p>PC 客户端代码：</p>

<pre><code>try {
        // 6665是 PC 端的端口，通过运行该 Shell 命令重定向到 Android Device 的6666端口 (端口自己定，不得超过1023)
        Runtime.getRuntime().exec("[Your Android SDK's Dir]\\platform-tools\\adb.exe forward tcp:6665 tcp:6666");
    } catch (IOException e) {
        e.printStackTrace();
        return;
    }

    Socket socket = null;
    try {
        InetAddress serverAddr = null;
        serverAddr = InetAddress.getByName("127.0.0.1");
        System.out.println("Start to connect android");

        socket = new Socket(serverAddr, 6665);

        String message = "I'm pc";
        System.out.println("Pc is sending message: " + message);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);
        out.println(message);
        Thread.sleep(5000);

        // receive message from server (Android Device)
        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        String msg = br.readLine();
        System.out.println(msg);
    } catch (UnknownHostException e) {
        System.out.println(e);
    } catch (IOException e) {
        System.out.println(e);
    } finally {
        try {
            if (socket != null) {
                socket.close();
            }
        } catch (IOException e) {
            System.out.println(e);
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Problem With JQuery's Html() Function in IE]]></title>
    <link href="http://smilevchy.github.io/blog/2014/09/16/jquerys-html-function-in-ie/"/>
    <updated>2014-09-16T21:20:02+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/09/16/jquerys-html-function-in-ie</id>
    <content type="html"><![CDATA[<pre><code>&lt;div id="container"&gt;
&lt;/div&gt;
&lt;div id="btnArea"&gt;
    &lt;input type="button" value="clear" id="clearBtn" /&gt;
    &lt;input type="button" value="add" id="addBtn" /&gt;
&lt;/div&gt;
</code></pre>

<!-- more -->


<pre><code>&lt;script&gt;
    $(function() {
        var tempDom = $("&lt;span&gt;hello world&lt;/span&gt;");
        $("#container").append(tempDom);

        $("#btnArea").delegate("#clearBtn", "click", function(evt) {
            $("#container").html("");
        });

        $("#btnArea").delegate("#addBtn", "click", function(evt) {
            $("#container").append(tempDom);               
        });
    });
&lt;/script&gt;   
</code></pre>

<p>上面那段代码在 Chrome、Firefox 下运行时，能够得到期望的结果，而如果在 IE 浏览器下运行时，其输出行为与预料中的不一样(此时 tempDom 的文本节点会被删除掉，感觉像在tempDom 上调用了 html())。
为了 hack 这个问题，可以写成，预先把节点保存起来，在需要的时候就 clone 该节点来进行操作。</p>

<p>即：</p>

<pre><code>&lt;script&gt;
    $(function() {
        var tempDom = $("&lt;span&gt;hello world&lt;/span&gt;");
        $("#container").append(tempDom.clone());

        $("#btnArea").delegate("#clearBtn", "click", function(evt) {
            $("#container").html("");
        });

        $("#btnArea").delegate("#addBtn", "click", function(evt) {
            $("#container").append(tempDom.clone());               
        });
    });
&lt;/script&gt;
</code></pre>

<p>这样没有什么效率，可以改成按需显示隐藏的方式(前提是符合项目需求)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/08/27/todays-shock/"/>
    <updated>2014-08-27T21:04:45+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/08/27/todays-shock</id>
    <content type="html"><![CDATA[<p>今天在阅读论文 &lt;Architectural Styles and the Design of Network-based Software Architectures&gt; 中，里面谈到了 HTTP 协议的定义。它明确指出了一个观点：“HTTP 并不是一种传输协议”。HTTP 并不是被设计为一种传输协议（transport protocol），它是一种转移协议（transfer protocol）。</p>

<!-- more -->


<p>这都是因为HTTP 在刚刚传入中国时被翻译成了“超文本传输协议”，然后大家都互相传播，造成了现在大家对 HTTP 的表述就是 “超文本传输协议”。</p>
]]></content>
  </entry>
  
</feed>
