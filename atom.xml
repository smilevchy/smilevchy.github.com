<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[smilevchy's blog]]></title>
  <link href="http://smilevchy.github.io/atom.xml" rel="self"/>
  <link href="http://smilevchy.github.io/"/>
  <updated>2014-11-17T18:43:07+08:00</updated>
  <id>http://smilevchy.github.io/</id>
  <author>
    <name><![CDATA[smilevchy]]></name>
    <email><![CDATA[smilevchy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode_Pascal's Triangle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-pascals-triangle/"/>
    <updated>2014-11-17T18:42:09+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-pascals-triangle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/pascals-triangle/">https://oj.leetcode.com/problems/pascals-triangle/</a></p>

<!-- more -->


<pre><code>public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
    if (numRows &lt;= 0) return new ArrayList&lt;List&lt;Integer&gt;&gt;();

    List&lt;List&lt;Integer&gt;&gt; pascalNums = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows);

    List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(1);
    row.add(1);
    pascalNums.add(row);

    for (int i = 1; i &lt; numRows; i++) {
        row = new ArrayList&lt;Integer&gt;(i + 1);

        for (int j = 0; j &lt;= i; j++) {
            if (j == 0) {
                row.add(pascalNums.get(i - 1).get(0));
            } else if (j == i) {
                row.add(pascalNums.get(i - 1).get(pascalNums.get(i - 1).size() - 1));
            } else {
                row.add(pascalNums.get(i - 1).get(j - 1) + pascalNums.get(i - 1).get(j));
            }
        }

        pascalNums.add(row);
    }

    return pascalNums;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Path Sum]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-path-sum/"/>
    <updated>2014-11-17T18:18:32+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-path-sum</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/path-sum/">https://oj.leetcode.com/problems/path-sum/</a></p>

<!-- more -->


<pre><code>public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;

    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) {
        return true;
    } if (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) {
        return true;
    }

    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Remove Duplicates From Sorted List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-remove-duplicates-from-sorted-list/"/>
    <updated>2014-11-17T17:25:01+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p>

<!-- more -->


<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;

    ListNode slowCursor = head;
    ListNode quickCursor = head.next;

    while (quickCursor != null) {
        if (quickCursor.val != slowCursor.val) {
            slowCursor = slowCursor.next;
            quickCursor = quickCursor.next;

            continue;
        }

        slowCursor.next = quickCursor.next;
        quickCursor = quickCursor.next;
    }

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Triangle]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/17/leetcode-triangle/"/>
    <updated>2014-11-17T17:08:01+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/17/leetcode-triangle</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/triangle/">https://oj.leetcode.com/problems/triangle/</a></p>

<!-- more -->


<pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
    if (triangle == null) return 0;

    int size = triangle.size();
    int[] res = new int[triangle.get(size - 1).size()];

    for (int i = 0, s = triangle.get(size - 1).size(); i &lt; s; i++) {
        res[i] = triangle.get(size - 1).get(i);
    }

    for (int i = size - 2; i &gt;= 0; i--) {
        for (int j = 0; j &lt;= i; j++) {
            res[j] = Math.min(res[j], res[j + 1]) + triangle.get(i).get(j);
        }
    }

    return res[0];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Word Break]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/14/leetcode-word-break/"/>
    <updated>2014-11-14T17:45:56+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/14/leetcode-word-break</id>
    <content type="html"><![CDATA[<p>原题链接：<a href="https://oj.leetcode.com/problems/word-break/">https://oj.leetcode.com/problems/word-break/</a></p>

<!-- more -->


<p>&ndash;_&ndash; 一开始用的是穷举法，结果遇到超长字符串时 online-judge system 就会报 limited time exceed 的错。</p>

<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; dict) {
    if (s == null || s.length() == 0) return true;

    int length = s.length();
    boolean[] res = new boolean[length + 1];
    res[0] = true;

    for (int i = 0; i &lt; length; i++) {
        StringBuilder sb = new StringBuilder(s.substring(0, i + 1));

        for (int j = 0; j &lt;= i; j++) {
            if (res[j] &amp;&amp; dict.contains(sb.toString())) {
                res[i + 1] = true;

                break;
            }

            sb.deleteCharAt(0);
        }
    }

    return res[length];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today's Shock]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/13/todays-shocking/"/>
    <updated>2014-11-13T14:12:18+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/13/todays-shocking</id>
    <content type="html"><![CDATA[<p>Need to sort some values which are Chinese.</p>

<p>Firstly, I am thinking to find some third-party libraries to finish this job. However, this may seems to be &ldquo;heavy&rdquo; for project.</p>

<!-- more -->


<p>So I turn to find some useful algorithms.</p>

<p>On Internet, I have found some solutions about how to do this. But some of them look like too bulk. So wandering and wandering, at last I found a sulution which looks the best currently. Some guy say we can use javascript&rsquo;s function : localeCompare().</p>

<p>So, it is what I want to get. Currently it works well, but maybe it will have some drawbacks.</p>

<p>Anyhow, it is a work around now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Insertion Sort List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/12/leetcode-insertion-sort-list/"/>
    <updated>2014-11-12T16:32:44+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/12/leetcode-insertion-sort-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/insertion-sort-list/">https://oj.leetcode.com/problems/insertion-sort-list/</a></p>

<!-- more -->


<p>一开始的解法有考虑到当前待插节点的后续节点，其实是没必要的</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) return null;

    ListNode cursorOut = head.next;
    ListNode cursorOutPrev = head;

    while (cursorOut != null) {
        ListNode cursorIn = head;
        ListNode cursorInPrev = null;
        ListNode cursorOutNext = cursorOut.next;

        while (cursorIn != null &amp;&amp; cursorIn != cursorOut) {
            if (cursorIn.val &gt; cursorOut.val) {
                if (cursorInPrev != null) {
                    cursorInPrev.next = cursorOut;
                } else {
                    head = cursorOut;
                }
                cursorOutPrev.next = cursorOutNext;
                cursorOut.next = cursorIn;
                cursorOut = cursorOutPrev;

                break;
            }

            cursorInPrev = cursorIn;
            cursorIn = cursorIn.next;
        }

        cursorOutPrev = cursorOut;
        cursorOut = cursorOutNext;
    }
}
</code></pre>

<p>使用额外的一个节点来记录遍历位置</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) return null;

    ListNode insertedNode = head;
    ListNode cursor = new ListNode(0);
    ListNode prev = null;

    while (insertedNode != null) {
        ListNode insertedNodeNext = insertedNode.next;
        prev = cursor;

        while (prev.next != null &amp;&amp; prev.next.val &lt;= insertedNode.val) {
            prev = prev.next;
        }

        insertedNode.next = prev.next;
        prev.next = insertedNode;
        insertedNode = insertedNodeNext;
    }

    return cursor.next;
}       
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Roman to Integer]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/11/leetcode-roman-to-integer/"/>
    <updated>2014-11-11T18:31:43+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/11/leetcode-roman-to-integer</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/roman-to-integer/">https://oj.leetcode.com/problems/roman-to-integer/</a></p>

<!-- more -->


<pre><code>// I(1) V(5) X(10) L(50) C(100) D(500) M(1000)
public int romanToInt(String s) {
    if (s == null) return 0;

    s = s.trim();

    if (s.equals("")) return 0;

    int num = 0;
    int length = s.length();
    char cur;
    char next;

    for (int i = 0; i &lt; length; i++) {
        cur = s.charAt(i);

        switch (cur) {
            case 'I':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'V') {
                        num += 4;
                        i++;
                        continue;
                    } else if (next == 'X') {
                        num += 9;
                        i++;
                        continue;
                    }
                }

                num += 1;

                break;

            case 'V':
                num += 5;

                break;

            case 'X':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'L') {
                        num += 40;
                        i++;
                        continue;
                    } else if (next == 'C') {
                        num += 90;
                        i++;
                        continue;
                    }
                }

                num += 10;

                break;

            case 'L':
                num += 50;

                break;

            case 'C':
                if (i + 1 != length) {
                    next = s.charAt(i + 1);

                    if (next == 'D') {
                        num += 400;
                        i++;
                        continue;
                    } else if (next == 'M') {
                        num += 900;
                        i++;
                        continue;
                    }
                }

                num += 100;

                break;

            case 'D':
                num += 500;
                break;

            case 'M':
                num += 1000;
                break;
        }
    }

    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Sorrow of Individual Game Developer]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/10/the-sorrow-of-individual-game-developer/"/>
    <updated>2014-11-10T22:16:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/10/the-sorrow-of-individual-game-developer</id>
    <content type="html"><![CDATA[<p>想自己做个游戏，代码还好说，有困难的是各种图片资源、音效资源的创建。
画家天赋、音乐天赋均没有点上&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Longest Common Prefix]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/08/leetcode-longest-common-prefix/"/>
    <updated>2014-11-08T13:51:55+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/08/leetcode-longest-common-prefix</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/longest-common-prefix/">https://oj.leetcode.com/problems/longest-common-prefix/</a></p>

<!-- more -->


<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs == null) return null;
    if (strs.length == 0) return "";

    String shortestStr = null;

    // find the shortest string element
    for (int i = 0, s = strs.length; i &lt; s; i++) {
        if (shortestStr == null) {
            shortestStr = strs[i];
        } else if (strs[i].length() &lt; shortestStr.length()) {
            shortestStr = strs[i];
        }
    }

    StringBuilder longestCommonPrefix = new StringBuilder("");
    int shortestStrLen = shortestStr.length();
    char c;
    boolean quitMatch = false;

    for (int i = 0; i &lt; shortestStrLen; i++) {
        c = shortestStr.charAt(i);

        for (int j = 0, s = strs.length; j &lt; s; j++) {
            if (strs[j].charAt(i) != c) {
                quitMatch = true;
                break;
            }

            if (j == strs.length - 1) {
                longestCommonPrefix.append(c);
            }
        }

        if (quitMatch) break;
    }

    return longestCommonPrefix.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Palindrome]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome/"/>
    <updated>2014-11-07T16:28:29+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-valid-palindrome</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/valid-palindrome/">https://oj.leetcode.com/problems/valid-palindrome/</a></p>

<!-- more -->


<pre><code>public boolean isPalindrome(String s) {
    if (s == null) return false;

    s = s.trim();

    if (s.equals("")) return true;

    int i = 0;
    int j = s.length() - 1;
    char leftChar;
    char rightChar;

    while (i &lt; j) {
        leftChar = s.charAt(i);

        if ((leftChar &lt; 'a' || leftChar &gt; 'z') &amp;&amp; (leftChar &lt; 'A' || leftChar &gt; 'Z') &amp;&amp; (leftChar &lt; '0' || leftChar &gt; '9')) {
            i++;
            continue;
        }

        rightChar = s.charAt(j);

        if ((rightChar &lt; 'a' || rightChar &gt; 'z') &amp;&amp; (rightChar &lt; 'A' || rightChar &gt; 'Z') &amp;&amp; (rightChar &lt; '0' || rightChar &gt; '9')) {
            j--;
            continue;
        }

        if (leftChar &gt; rightChar) {
            if (leftChar - 32 != rightChar) return false;
        } else if (leftChar &lt; rightChar) {
            if (leftChar + 32 != rightChar) return false;
        }

        i++;
        j--;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Count and Say]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say/"/>
    <updated>2014-11-07T15:53:37+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/07/leetcode-count-and-say</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/count-and-say/">https://oj.leetcode.com/problems/count-and-say/</a></p>

<!-- more -->


<pre><code>public String countAndSay(int n) {
    if (n &lt; 0) return "";

    StringBuilder sb = new StringBuilder();

    if (n == 1) {
        return sb.append("1").toString();
    }

    String prevStr = countAndSay(n - 1);
    int length = prevStr.length();
    char prevChar = ' '; 
    int accumulator = 0;

    for (int i = 0; i &lt; length; i++) {
        char c = prevStr.charAt(i);

        if (c == prevChar) {
            accumulator++;
        } else {
            if (prevChar == ' ') {
                prevChar = c;
                accumulator = 1;
                continue;
            }

            sb.append("" + accumulator + prevChar);

            prevChar = c;
            accumulator = 1;
        }
    }

    if (accumulator &gt; 0) sb.append("" + accumulator + prevChar);

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Palindrome Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number/"/>
    <updated>2014-11-06T15:59:14+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/06/leetcode-palindrome-number</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/palindrome-number/">https://oj.leetcode.com/problems/palindrome-number/</a></p>

<!-- more -->


<pre><code>public boolean isPalindrome(int x) {
    if (x &lt; 0) return false;

    // get length of digit
    int carryLength = 1;
    while (x / carryLength &gt;= 10) {
        carryLength *= 10;
    }

    while (x &gt; 0) {
        // test if the first and the end digit is equal; if not, return false
        if (x / carryLength != x % 10) return false;

        x = x % carryLength / 10;    // get the new number without the first and the end digit
        carryLength /= 100;    // for cutting the first and the end digit, we need to shrink carry length by 2 times
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Valid Number]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number/"/>
    <updated>2014-11-05T18:29:57+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/05/leetcode-valid-number</id>
    <content type="html"><![CDATA[<p>原题链接：<a href="https://oj.leetcode.com/problems/valid-number/">https://oj.leetcode.com/problems/valid-number/</a></p>

<!-- more -->


<p>这道题主要是注意 &ldquo;+&rdquo;/&ldquo;&ndash;&rdquo;/&ldquo;e&rdquo;/&ldquo;E&rdquo;/&ldquo;.&rdquo; 的位置，遍历字符串，当遇到上述几种符号时就判断位置是否正确，不正确则退出遍历过程，正确则继续，遇到非数字则退出遍历过程。</p>

<pre><code>public boolean isNumber(String s) {
    if (s == null) {
        return false;
    }

    String str = s.trim();

    if (str.length() == 0) {
        return false;
    }

    boolean result = true;
    int length = str.length();
    char c;
    boolean exponentialExisted = false;
    boolean dotExisted = false;
    boolean quitLoop = false;
    boolean digitExisted = false;

    for (int i = 0; i &lt; length; i++) {
        c = str.charAt(i);

        if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
            digitExisted = true;
        } else {
            switch (c) {
                case '+':
                case '-':
                    if (i == length - 1 || i != 0 &amp;&amp; str.charAt(i - 1) != 'e' &amp;&amp; str.charAt(i - 1) != 'E') {
                        result = false;

                        quitLoop = true;
                    }

                    break;

                case 'e':
                case 'E':
                    if (exponentialExisted || i == 0 || i == length - 1 || ((str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9') &amp;&amp; str.charAt(i - 1) != '.') || !digitExisted) {
                        result = false;

                        quitLoop = true;
                    }

                    exponentialExisted = true;

                    break;

                case '.':
                    if (dotExisted || exponentialExisted || length == 1 || (i == length - 1 &amp;&amp; (str.charAt(i - 1) &lt; '0' || str.charAt(i - 1) &gt; '9')) || 
                        (i == 0 &amp;&amp; ((str.charAt(i + 1) &lt; '0' || str.charAt(i + 1) &gt; '9') &amp;&amp; (str.charAt(i + 1) != 'e' &amp;&amp; str.charAt(i + 1) != 'E')))) {
                        result =  false;

                        quitLoop = true;
                    }

                    dotExisted = true;

                    break;

                default:
                    result = false;
                    quitLoop = true;
            }
        }

        if (quitLoop) break;
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Jump Game]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-jump-game/"/>
    <updated>2014-11-04T21:34:32+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-jump-game</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/jump-game/">https://oj.leetcode.com/problems/jump-game/</a></p>

<!-- more -->


<p>~_~ 这道题是看别人的解法的（当然，我不是照抄那种，看过理解了自己再写的）</p>

<pre><code>public boolean canJump(int[] A) {
    if (A == null || A.length == 0) {
        return false;
    }

    int size = A.length;
    int dstPosition = size - 1;
    int maxReachPosition = 0;

    for (int i = 0; i &lt;= maxReachPosition &amp;&amp; i &lt; size; i++) {
        maxReachPosition = Math.max(i + A[i], maxReachPosition);
    }

    if (maxReachPosition &lt; dstPosition) {
        return false;
    }

    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Rotate List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-rotate-list/"/>
    <updated>2014-11-04T21:32:39+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-rotate-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/rotate-list/">https://oj.leetcode.com/problems/rotate-list/</a></p>

<!-- more -->


<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return head;
    }

    ListNode cursor = head;

    int length = 0;
    while (cursor != null) {
        cursor = cursor.next;
        length++;
    }

    if (n % length == 0) {
        return head;
    }

    int targetIndex = length - n % length;

    int currentIndex = 0;
    cursor = head;
    ListNode prev = null;

    while (currentIndex &lt; targetIndex) {
        prev = cursor;
        cursor = cursor.next;
        currentIndex++;
    }

    ListNode cursorTail = cursor;
    while (cursorTail.next != null) {
        cursorTail = cursorTail.next;
    }

    prev.next = null;
    cursorTail.next = head;
    head = cursor;

    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Reverse Words in a String]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-words-in-a-string/"/>
    <updated>2014-11-04T21:30:38+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-reverse-words-in-a-string</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">https://oj.leetcode.com/problems/reverse-words-in-a-string/</a></p>

<!-- more -->


<pre><code>public String reverseWords(String s) {
    String[] words = s.trim().split("\\s+");
    StringBuilder sb = new StringBuilder("");

    for (int i = words.length - 1; i &gt;= 0; i--) {
        sb.append(words[i]);

        if (i &gt;= 1) {
            sb.append(" ");
        }
    }

    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Reorder List]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-reorder-list/"/>
    <updated>2014-11-04T21:23:58+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-reorder-list</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/reorder-list/">https://oj.leetcode.com/problems/reorder-list/</a></p>

<p>正是这道题，让我知道了有 “快慢指针” 这种好东西。以前每当要做类似遍历链表的操作时，比如取中点，总是先遍历完一遍链表来获得长度，求得中点再遍历一次，实在是不雅观。而通过 “快慢指针”，只要写一次遍历就可以拿到中点。</p>

<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }

    ListNode slowCursor = head;
    ListNode quickCursor = head;

    while (quickCursor != null &amp;&amp; quickCursor.next != null &amp;&amp; quickCursor.next.next != null &amp;&amp; slowCursor != null &amp;&amp; slowCursor.next != null) {
        slowCursor = slowCursor.next;
        quickCursor = quickCursor.next.next;
    }

    ListNode head1 = head;
    ListNode head2 = slowCursor.next;

    head2 = reverseList(head2);

    while (head1 != null &amp;&amp; head2 != null) {
        ListNode head2Next = head2.next;
        head2.next = head1.next;
        head1.next = head2;
        head1 = head2.next;
        head2 = head2Next;

        if (head2 == null) {
            head1.next = null;
        }
    }
}

public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode cursor = head;
    ListNode next = null;

    while (cursor != null) {
        next = cursor.next;
        cursor.next = prev;
        prev = cursor;
        cursor = next;
    }

    return prev;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Add Two Numbers]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-add-two-numbers/"/>
    <updated>2014-11-04T21:21:13+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-add-two-numbers</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/add-two-numbers/">https://oj.leetcode.com/problems/add-two-numbers/</a></p>

<!-- more -->


<pre><code>public ListNode addTwoNumbers(ListNode left, ListNode right) {
    if (left == null &amp;&amp; right == null) {
        return null;
    }

    ListNode result = new ListNode(0);
    ListNode cursor = result;
    int carry = 0;

    while (left != null || right != null) {
        int val = 0;

        if (left != null) {
            val += left.val;
            left = left.next;
        }

        if (right != null) {
            val += right.val;
            right = right.next;
        }

        val += carry;
        int digit = val % 10;
        carry = val / 10;

        cursor.val = digit;

        if (left != null || right != null) {
            cursor.next = new ListNode(0);
            cursor = cursor.next;               
        }
    }

    if (carry &gt; 0) {
        cursor.next = new ListNode(1);
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode_Plus One]]></title>
    <link href="http://smilevchy.github.io/blog/2014/11/04/leetcode-plus-one/"/>
    <updated>2014-11-04T21:19:18+08:00</updated>
    <id>http://smilevchy.github.io/blog/2014/11/04/leetcode-plus-one</id>
    <content type="html"><![CDATA[<p>原题链接: <a href="https://oj.leetcode.com/problems/plus-one/">https://oj.leetcode.com/problems/plus-one/</a></p>

<!-- more -->


<pre><code>public byte[] plusOne(byte[] num) {
    if (num == null || num.length == 0) {
        return num;
    }

    byte[] result = num.clone();
    int length = num.length;

    for (int i = length - 1; i &gt;= 0; i--) {
        byte digit = result[i];
        result[i] = (byte) (digit + 1);

        if (result[i] &lt; 10) {
            break;
        } else {
            result[i] = 0;

            if (i == 0) {

                byte[] expandedNum = new byte[length + 1];
                expandedNum[0] = 1;

                return expandedNum;
            }
        }
    }

    return result;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
